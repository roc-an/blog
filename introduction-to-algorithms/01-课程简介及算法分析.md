# 01-课程简介及算法分析

本套课程分为两大主题，第一块主题是**算法分析**，第二块是**算法设计**。

在开始设计算法之前，我们不得不掌握一些分析算法的实用技巧，这样才能知道哪一种算法方式更有效。

## （一）算法分析介绍

**算法分析属于理论研究，是关于计算程序性能和资源利用的研究，这里尤其关注性能。**

我们要学习如何让计算机程序变得更快，我们也将涉及并讨论其他问题，例如通信、存储器（不管是内存或是磁盘存储）。

Q：思考一个问题，如果你在写一段程序，有什么是比性能更重要的呢？
A：正确性、简洁、可维护性、程序员的时间成本、稳定性、软件所拥有的功能特性、模块化。还有一个点也非常重要，那就是安全性（2000 年以后，安全变得比性能更加重要）。

Q（追问）：还有什么重大的突破？为什么人们更青睐苹果操作系统，而不是 Windows，这些人简直成了苹果的教徒？
A：用户体验友好。如果你一直关注计算机的发展历程，你就会见证 90 年代计算机是如何进入用户友好时代。从几乎空白的状态演进到了目前友好的用户体验。因此，以上这些所有事情，都要比性能重要。

### 为什么要学习算法？

这是一门讨论性能的课，如果算法和性能都不重要，为什么还要学习它们？

这里有几点重要的原因：

1.通常，**性能的好与坏，直接决定着可行还是不可行。**例如，对于实时的需求，如果程序不快，这只能表示它不可行。或者，如果它占用过多的内存，也只能说是不可行。

所以，算法总是处于解决问题的最前沿。如果你讨论的只是重新实现十年前人们就做过的东西，那某种意义上，性能就不再重要。但是如果你正在积极尝试其他人没有成功的事情，之所以别人没有成功，因为太消耗时间、不具备可扩展的空间。这是第一层原因，**算法能够将不可行变为可行（feasible versus infeasible）**。

2.第二层原因，**算法是一种描述程序行为的语言**。它逐渐成为一种广泛应用于计算机科学领域、已经被所有的实践者所采用的理论语言，它是一种让程序最为简洁的思考方式。我们有一个很好的比喻来形容性能，以及为何性能处于最底层，它所扮演的角色就如同经济中的货币一般。

想想一沓一百美元的钞票有什么好的？你也许更需要有食物、水、房子等等，你需要用钞票才能......（前提是你有的话），才能买下这些商品。尽管水对于你的生命比钞票重要。同样，性能是确保良好的用户体验的前提，也是安全的保障。

你可能听别人说到，我希望有更多的功能，因此人们会用 Java 来写程序，尽管它比 C 写的程序要慢很多，有人说用 Java 编程性能会损失三倍左右，但是值得为 Java 付出这些代价，因为它提供面向对象的特性以及异常机制等等。所以人们能够接受三倍的性能损失。

这就是我们为什么需要性能，因为需要性能作为支付其他东西的“货币”，因为它作为衡量一个程序的一般性标准，你会考虑你愿意消耗 2 倍的性能在这块上面，还是消耗 3 倍的性能在安全上面，等等。

3.我们学习算法的最后一层原因，**这里充满了兴趣**。速度永远让人渴望，对吗？为什么人们喜欢驾驶跑车、赛马、滑雪这些快速的东西？还比如火箭，为什么？因为我们向往速度。

以上，这是为什么学习算法的一些基本概念，这些是开展后续课程的基本前提。我们希望知道如何才能让计算转化为金钱。

## （二）排序问题

让我们从一个非常简单的问题开始，这是一个在算法学习中最古老的问题。就是**排序问题**。排序包含了很多基本算法，我们将用几个课时来介绍它。

举一个排序的例子：

输入：`n` 个数的一组序列 `<a1, a2, ..., an>`
输出：输入序列的一个排列 `<a1', a2', ..., an'>`，满足 `a1' <= a2' <= ... <= an'`

排序后每个数字出现且仅出现一次，让它们由小到大依次递增。

我们先用一段伪代码来描述插入排序（Insertion-Sort），伪代码能够让我们更容易理解算法所要表达的意思：

注意，我们将伪代码的过程命名为 `INSERTION-SORT`，参数是一个数组 `A[1..n]`，包含着 `n` 个要排序的数。`A` 中元素的数目用 `A.length` 表示。另外和 JS 不同，伪代码中数组元素是从索引 1 开始的，而不是 JS 中的 0。

```
INSERTION-SORT(A)
  for j = 2 to A.length
    key = A[j]

    // 将 A[j] 插入到排序后数组 A[1..j - 1] 中
    i = j - 1
    while i > 0 and A[i] > key
      A[i + 1] = A[i]
      i = i - 1
    A[i+1] = key
```

要想第一次就搞懂上面的步骤，还是有挑战性的，这里给大家放出来书中的例子，可以对照着伪代码理一遍就有思路了：`A = <5, 2, 4, 6, 1, 3>`。

其实这个算法的场景在生活中人们大多都经历过。就是**给扑克牌排序**。如图：

可以将整个过程比作给手里的一把扑克牌从左至右、从小到大依次排序，那么：

```
INSERTION-SORT(A)
  for j = 2 to A.length // 一开始从左数第 2 张牌开始
    key = A[j] // 将当前要比较的牌抽出来，开始往左看，思考要放在哪
    i = j - 1 // 先比较前一张牌

    while i > 0 and A[i] > key // 如果前一张还有牌（就是 i > 0），并且前一张牌还比当前抽出的牌点大
      A[i + 1] = A[i] // 那就把前一张牌后移
      i = i - 1 // 之后继续比较再前一张牌。以此类推，直到比较到前面没牌，或者前面牌的点数小于等于抽出牌点数时停止
    A[i+1] = key // 最后再将抽出的牌插入到相应的位置（即最终比较的前一张牌的后面），排序结束。
```

搞懂代码执行流程后，我们进一步分析这其中的思想。

这段排序算法，有**内外两层循环**：

* 外层循环，循环条件是 `j` 从 2 递增到数组长度 `n`；
* 内层循环，循环开始于 `j - 1`，并递减至 0，或者递减到前一个数不再比当前的 `key` 变量存着的数大。

再深入循环内部。

在每个外层循环中，先找到 `j` 这个位置，把数组的 `j` 这个位置的数字提取出来，称之为键值 `key`。

接下来这点很重要。算法中**存在一个「循环不变式（invariant）」，每次循环都将保持着这个不变式。**这个不变式就是数组已经排序过的部分。
