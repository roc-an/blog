# 从浏览器地址栏中输入 URL 到看到页面，中间经历了什么？

## （一）概述

这是一道非常综合的面试题，内容涉及了操作系统、浏览器底层原理、网络通信以及页面渲染相关的知识，可以考察应聘者的技术视野和技术深度。

另外抛开面试不谈，如果能够理解从输入 URL 到页面渲染完成的整个过程细节，对于我们进行 Web 性能优化、问题定位都是非常有帮助的，可以让我们站在更高的角度去看待自己写的代码。

这篇文章会对详细流程进行分析，并对涉及到的相关知识进行较详细的讲解。

无论是输入 URL，或是进行网络请求，还是渲染页面，进行这些操作的都是浏览器。现代浏览器采用的都是**多进程架构**，不同进程负责不同的事情，要想把整体流程理解透彻，首先要搞清楚浏览器中有哪些进程，分别负责处理什么事情。

## （二）浏览器的多进程架构

### 线程的并行处理执行

先从线程说起，**线程（Thread）是操作系统能够进行运算调度的最小单位**。也就是说，如果我们的电脑要执行某项任务，没有比线程更小的拆分粒度了。

那么问题来了，执行一项任务，大任务可以拆分成小任务给不同的线程去执行，那线程可以并行处理任务吗？如果可以，那不就能大大缩短执行这个大任务的时间咯？

答案是可以的，**线程可以并行处理任务**。

比如下面这 3 行代码就包含了 3 个要处理的小任务：

```js
let a = 1 + 2; // 任务1：计算 1 + 2 的值，赋值给变量 a
let b = 3 / 3; // 任务2：计算 3 / 3 的值，赋值给变量 b
console.log(a, b); // 任务3：浏览器控制台打印变量 a 和 b 的值
```

如果用**单线程**来处理，需要 3 步，即一个线程依次执行上面的 3 行代码。

但如果用**多线程**来处理，仅需要 2 步：

1. 使用 2 个线程，分别执行任务 1 和任务 2，得到赋值后的变量 a 和变量 b
2. 使用 1 个线程，执行任务 3，打印变量

所以，**线程的并行处理执行可以大大提升性能。**

### 进程负责线程的调度

但是线程多起来了以后，由谁管理呢？这就要说到进程了。

**一个进程（Process）就是操作系统中一个应用程序的运行实例，进程包含多个线程，负责线程的启动和调度，可以支持线程的并行处理执行。**

上面多线程并行处理的代码，如果用图来表示，就是这样：

**进程和线程的关系：**

**1.只要进程中任一线程执行出错，都会导致整个进程崩溃**

比如，如果把之前的 3 行代码改成这样：

```js
let a = 1 + 2; // 任务1：计算 1 + 2 的值，赋值给变量 a
let b = c / 3; // 任务2：计算 c / 3 的值，赋值给变量 b
console.log(a, b); // 任务3：浏览器控制台打印变量 a 和 b 的值
```

在执行任务 2 时，由于找不到变量 `c`，于是执行出错，一旦出错，整个进程也就崩溃了，就轮不到线程再去执行任务 3 了。

**2.线程之间共享进程中的资源**

上图任务执行过程中需要进行变量的赋值/取值操作，也就是数据的写和读，这些数据在进程中是可以被各个线程所共享访问的。

注意，“共享访问”并不意味着“同时访问”，如果同时有好多线程对同一个数据进行读写，那不就乱套了。

于是线程中存在一个叫**互斥锁（Mutex）**的东西。好比在旅游景点想去上个厕所，进去后把锁锁上（Lock），这样其他人再想用厕所就只能外边等着，等上完厕所出来，再把锁解开（Unlock），这样其他人又能接着用了。例子有点糙，不过道理确实是这么个道理。

**3.进程关闭后，操作系统会回收进程占用的内存**

无论进程是正常退出，还是因为线程执行出错而意外崩溃，系统都会对进程执行过程中申请的内存进行回收。如果没有这个机制，内存就会越用越多，最终被用光。

有时候我们打游戏，由于程序写的不好，系统越玩越卡，但一旦关了以后，一切又都好起来了，就是这个道理。

**4.进程间相互隔离**

一般情况下，一个进程只能访问自己的数据，这样做是为了避免进程间互相干扰。一个进程崩溃了，又导致其他进程跟着崩溃，那岂不控制不住了，所以操作系统才会有**进程隔离**的机制。

当然，进程间是允许进行数据交互的，这就要用到 IPC（Inter-Process Communication，进程间通信）了。

### 现代浏览器的多进程架构

终于要说到浏览器了，早期的浏览器都是采用的单进程架构，而目前的浏览器都改为采用**多进程架构**了。

也就是说，浏览器一开，咱们电脑系统上就会运行多个进程。以 Chrome 为例，它的多进程架构如图：

其中：

- 浏览器主进程：负责浏览器界面的展示、用户操作浏览器交互的处理、其他进程的调度以及存储功能；
- 网络进程：负责网络资源加载；
- GPU 进程：处理 GPU 渲染相关的任务，提升图形的渲染速度，降低 CPU 的负担；
- 渲染进程：放在沙箱（Sand Box）中，负责将 HTML/CSS/JS 解析、渲染成页面。排版引擎 Blink 和 V8 引擎都是运行在该进程中。
- 插件进程：负责浏览器插件的运行。单独给插件一个进程是因为插件往往最容易崩溃，不能因为一个插件的崩溃导致浏览器的渲染或是网络加载也崩溃了，所以才单独给了个进程，防止对其他进程干扰（渲染进程也是相对不稳定的，JS 写的烂就会崩溃，所以也单独提了个渲染进程）。

#### 图中的沙箱是怎么回事？为什么渲染进程和插件进程要放到沙箱中？

浏览器**沙箱（Sand Box）**中的进程是不能在硬盘上读写数据的，这样就把里面的进程和操作系统关键的数据进行了隔离。

渲染进程和插件进程放到沙箱中，即便他们运行出错，甚至是执行一些恶意程序，也无法去获取系统操作权限从而破坏系统。

所以把它们放到浏览器沙箱中是基于安全的考虑。

#### 多进程架构的优势

- 稳定性：上面已经提到，把不稳定的插件和页面渲染任务，单独放到各自的进程中去，即便它们的进程崩了，也不会影响整个浏览器，这样大大提升了浏览器运行的稳定性；
- 流畅度：
  - 早期单进程架构下，如果写了一段死循环的 JS 代码，那么这段骚代码的执行独占了整个线程，其他线程没有机会执行，就会导致整个浏览器变卡顿甚至无响应。但改为多进程后，即便死循环的代码导致当前渲染进程无响应了，也不会影响其他渲染进程，其他页面还是好好的；
  - 另一个问题是**内存泄漏**，单进程下，如果一个线程的执行程序写的比较烂，出现了内存泄漏，那么即便线程执行后关闭释放了一部分内存，但随着有内存泄露的线程的执行越来越多，没被释放的内存越来越多，最终整个浏览器进程就会越用越“慢”。多进程架构下，即便一个页面有内存泄露，但是当关闭它时，整个对应的渲染进程也推出了，进程占用的内存会被完全回收，这也就解决了内存泄露的问题；
- 安全性：早期单进程浏览器没有沙箱机制，这是非常不安全的。一些用 C/C++ 编写的恶意插件可以直接操作计算机中的资源，而恶意脚本也可以通过浏览器漏洞来获取系统权限。多进程架构下的沙箱机制使得这些安全性问题得到有效解决。

#### 多进程架构的劣势

虽然多进程架构解决了上述的稳定性、流畅度以及安全性问题，但由于架构比较复杂，还是会带来一些问题：

- 资源占用高：每个进程都要包含公共基础结构的副本（比如 JS 运行环境），这就令使用浏览器时占用的内存资源更多；
- 扩展性差：也正是由于架构比较复杂，导致模块与模块间的耦合度较高，比较难以适应新需求。

所以目前 Chrome 团队依然在不断探索，往**面向服务的架构（Services Oriented Architecture，SOA）**方向不断努力。

## （三）从 URL 到页面渲染完成的整体流程

介绍了浏览器的多进程架构，回到题目本身，从用户在浏览器地址栏中输入 URL，到最终看到页面渲染完毕，整体流程如图：

你会发现，整个流程中并不是一个进程单独搞定的，而是由浏览器主进程、网络进程以及渲染进程配合搞定的。

概括地看，可以把整个流程分为以下 4 个阶段：

1. 用户输入 URL，浏览器主进程把收到的 URL 转给网络进程；
2. 网络进程中发起请求，其中还涉及缓存、DNS 解析、重定向。等网络进程拿到响应头，解析后，将响应头解析后数据转发给浏览器主进程；
3. 浏览器主进程收到响应头数据，发送“提交导航（Commit Navigation）”消息给渲染进程，渲染进程收到后给浏览器主进程回话，告诉主进程已经准备好接收页面了，发给主进程“确认提交”消息。之后渲染进程和网络进程建立通信管道，准备接收 HTML；
4. 浏览器收到“确认提交”消息后，移除之前的旧页面。渲染进程收到网络进程传来的页面数据后，加载资源、解析，最终完成页面渲染。

图中从用户输入 URL 后浏览器主进程开始处理，到渲染进程收到响应数据开始页面解析前的这段过程，叫**导航**。

下面对各个阶段，按顺序进行详细地说明。

## （四）浏览器主进程处理用户 URL 输入

**1.触发旧页面的 beforeunload 事件**

如果是在一个已有网站的标签页地址栏上输入 URL 后回车，进行后续操作前，会先触发当前旧页面的 [beforeunload](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/beforeunload_event) 事件。

这时可以询问用户是否要离开页面，一个常见的场景就是，用户还在填表单，结果不小心点到了标签页的 X，这时候网站友好地询问用户确定要离开吗。

如果用户取消掉了，那后续的一系列导航操作就不会发生了。

**2.判断是搜索内容还是页面请求的 URL**

接着，会对用户在地址栏上输入的内容进行判断。

如果判断是搜索内容，就用浏览器默认的搜索引擎，拼好搜索关键字的 URL 去准备访问搜索引擎的网站。

比如我在地址栏输入“github”，这明显不是网址，默认搜索引擎如果是百度，按下回车，URL 就会被拼成 `https://www.baidu.com/s?ie=UTF-8&wd=github`，然后就显示出百度的搜索结果了。

如果判断符合网址 URL 规则，那么就准备去访问网站。

比如输入 `github.com`，按下回车，URL 就会变成 `https://github.com/`，然后跳转到 Github 网站上去了。当然，这里还涉及到**重定向**，后文中会讲到。

接着，浏览器主进程将拼好的 URL 通过进程间通信（IPC）交给网络进程。

但注意，此时页面是不会更新的，页面还是旧页面，只是标签页上的转圈圈开始转起来了，只有当后面“确认提交”的操作后，才会替换页面内容为新页面。

## （五）网络进程处理请求

网络进程收到 URL 后，就要开始发送 HTTP 请求来请求页面了，也就是说，接下来就要到**HTTP 请求流程**了。

整个 HTTP 请求流程如下：

1. 构建请求；
2. 查找缓存；
3. DNS 解析，准备 IP 地址及端口号；
4. 等待 TCP 队列；
5. 建立 TCP 连接，三次握手；
6. 发送 HTTP 请求；
7. 接收到服务器响应；
8. 断开 TCP 连接，四次挥手。

第一步**构建请求**比较简单，就是浏览器要构建好**请求行**的信息。

### 查找缓存

在发起请求前，浏览器会先在浏览器缓存中找找，看是否有要请求的资源。

如果发现缓存中已经有要请求的资源副本了，那就没必要再发请求了。这样做可以大大缓解服务器的压力，同时也加快了客户端浏览器对于资源的加载。

如果没找到缓存，或者缓存已经过期了，那就只能乖乖发请求了。

### DNS 解析

虽然咱们现在有了 URL，比如 `https://github.com/roc-an/blog`，但是直接通过这个 URL 是没办法找到对应的 Github 服务器的。

因为在网络传输过程中，数据都是以**数据包**的形式**通过 IP 地址来找到接收方的**，IP 地址是用数字标识的，比如 `52.74.223.119`，咱们只有得到了 GitHub 服务器的 IP 地址，才能找到它。

于是，这就要用到 DNS（Domain Name System，域名系统）了，DNS 服务建立了从域名到 IP 地址的一一映射关系，通过 DNS 解析，能够将域名解析成对应的 IP 地址。

我们的域名解析简单来说就是在 DNS 上记录一条信息。

比如：`https://github.com/roc-an/blog 52.74.223.119:443`，其中 `52.74.223.119` 是 IP 地址，`443` 是端口号。

那为什么不直接在浏览器地址栏输入 IP 地址 + 端口号呢？

答案当然是可以，问题是你记得住么... 也正是因为 IP 地址根本记不住，所以才用好记的域名来代替。

有了 IP 地址和端口号，接着就可以进行下一步，建立 TCP 连接（因为建立 TCP 连接需要 IP 地址和端口号）。

### TCP/IP 协议介绍

在开始建立 TCP 连接之前，先简单介绍下 HTTP 请求中要经历的 TCP、IP 协议。

之前提到，**网络通信中数据是以数据包的形式传递的，有了 IP 地址，就可以通过 IP 地址将数据包传输给对应的主机**，那么：

- IP 协议（Internet Protocol，网际协议，简称 IP）：就是用来通过 IP 地址将数据包送达对应主机的；
- TCP 协议（Transmission Control Protocol，传输控制协议，简称 TCP）：是用来确保数据包能够完整地送达应用程序的。

这里画一个图来说明数据包是如何通过 TCP、IP 协议从一个主机送达另一个主机的：

数据在网络中传输可能会存在这 2 个问题：

1. 数据传输过程中丢失了（丢包）怎么办？
2. 大文件都是被拆成很多小数据包传输的，接收方收到这些数据包的时间不同，那么怎么才能按顺序来重新组装这些数据包，还原成原来的完整的文件？

TCP 就是专门用来解决这 2 个问题的。**TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议**

- 面向连接：在实际数据传输前，先做好传输方和接收方两方的准备工作，确认无误后再传输数据；
- 可靠：
  - 对于丢包情况，TCP 提供了重传机制；
  - TCP 中有排序机制，可以把数据包按顺序还原成完整文件。

因此，数据包由发送方主机到达传输层时，会添加 TCP 头，TCP 头中包含着：

- 本机端口号；
- 目标主机的端口号；
- 用于排序的序列号。

从传输层到达网络层后，继续添加 IP 头，IP 头包含着：

- IP 协议版本；
- 本机 IP 地址；
- 目标主机的 IP 地址（这也就是为什么在建立 TCP 连接之前，要先通过 DNS 解析拿到 IP 地址，因为网络层的 IP 协议要用）；
- 生存时间；
- 其他信息等...

TCP 和 IP 协议先介绍到这里，后面我们还会遇到。

回到 HTTP 请求的流程，通过 DNS 解析拿到目标主机的 IP 地址和端口号，接下来就要进行 TCP 连接的创建了。

### 等待 TCP 队列

在建立 TCP 连接之前，浏览器还有个小限制。

Chrome 有个限制机制：一个域名下，同时最多只能建立 6 个 TCP 连接，如果超过 6 个，超过的连接操作要进入队列进行等待。

当然如果没有触及到这个限制机制，那下一步就是真正地去建立 TCP 连接了。

### 建立 TCP 连接（三次握手）

上面提到 TCP 是面向连接的，要先建立好客户端到服务器之间的连接，确保双方传输无误，然后再进行实际数据的传输。

建立 TCP 连接的过程，就是经典的“三次握手”过程，指的是客户端和服务器之间要发送 3 个数据包来确认连接的建立。

TCP 三次握手过程如下：

1. 客户端询问服务器是否可用：客户端发送一个带 `SYN=1, Seq=X` 的数据包到服务器端口；
2. 服务器告诉客户端自己可用：服务器返回一个带 `SYN=1, ACK=X+1, Seq=Y` 的响应包来传达确认信息；
3. 客户端再次告诉服务器-我知道了，我即将访问：客户端再发给服务器一个带 `ACK=Y+1, Seq=Z` 的数据包，握手结束。

一旦 TCP 连接建立好，接下来就可以在浏览器和服务器之间传输 HTTP 请求和响应的数据了。

### 发送 HTTP 请求并接收响应

浏览器将请求信息发送给服务器（请求行、请求头、请求体）：

- 请求行：包含着请求方式、请求 URI、协议版本；
- 请求头：浏览器信息、域名信息、Cookie 等；
- 请求体：请求传参、请求携带的数据。

服务器接收到请求后，进行业务处理，并返回响应（响应行、响应头、响应体）：

- 响应行：协议版本、状态码
- 响应头：服务器生成返回数据的时间、返回的数据类型、要在客户端设置的 Cookie 等；
- 响应体：响应数据本身，如果是访问页面，那么就返回页面的 HTML。

### 断开 TCP 连接（四次挥手）

服务器向客户端返回响应后，就可以断开 TCP 连接了。

断开 TCP 连接端可以是客户端，也可以是服务器端。

假设客户端发起了中断连接请求：

1. 第一次挥手：客户端先发送 `FIN` 报文，用来关闭主动方到被动关闭方的数据传送，也就是客户端告诉服务器“我已经不会再给你发数据了”（当然，在 `FIN` 包之前发送出去的数据，如果没有收到对应的 `ACK` 确认报文，客户端依然会重发这些数据），但此时客户端还可以接收数据；
2. 第二次挥手：服务器端接到 `FIN` 报文后，如果还有数据没有发送完成，那么不必急着关闭 `Socket`，可以继续发送数据。所以服务器端先发送 `ACK`，告诉客户端“请求已经收到了，但是我还没准备好，请继续等待停止的消息”。这时客户端就进入 `FIN_WAIT` 状态，继续等待服务器端的 `FIN` 报文；
3. 第三次挥手：当服务器端确定数据已发送完成，则向客户端发送 `FIN` 报文，告诉客户端“服务器这边数据发完了，准备好关闭连接了”；
4. 第四次挥手：客户端收到 `FIN` 报文后，就知道可以关闭连接了，但是它还是不相信网络，所以发送 `ACK` 后进入 `TIME_WAIT` 状态，服务器端收到 `ACK` 后，就知道可以断开连接了，于是断开连接。客户端等待了 2MSL 后依然没有收到回复，则证明服务器端已正常关闭。最后，客户端也可以关闭连接了。至此，TCP 连接就已完全断开了！

### 重定向

对于服务器返回的响应，有一种特殊情况，比如返回的 HTTP 状态码是 301，表示需要进行**重定向**。

比如文章开头提到的，如果我在地址栏输入 `github.com`，但最终跳转访问的页面是 `https://github.com/`，这就是因为中间经历了重定向。

我们可以通过 `curl` 工具来测试（`curl` 是用来测试 HTTP 请求的命令行工具，一般系统都自带）。

打开命令行，输入 `curl -I github.com`，其中 `-I` 参数表示只打印出响应行和响应头数据就行，不用管响应体。

输入后，返回的结果是这样：

```
HTTP/1.1 301 Moved Permanently
Content-Length: 0
Location: https://github.com/
```

可以看到，返回的 HTTP 状态码是 301，说明要重定向到另一个网页去访问。重定向到哪里呢？在 `Location` 字段中进行了说明。

于是，在浏览器收到重定向的响应后，就会用 `Location` 字段中的地址，重新发起导航，那么 HTTP 请求的创建，又要重新开始了。

### HTTP 请求过程小结

综上，从一开始构建请求，到最终断开 TCP 连接，一个完整的 HTTP 请求过程就完成了。

用一张图来表示：

其中一些要点：

- 构建请求后查找缓存，如果缓存可用，将会大大减少浏览器加载资源的时间，同时也会降低服务器的访问压力；
- 通过 DNS 解析，将域名解析为 IP 地址和端口号，从而才能继续后面的请求流程；
- 在发送 HTTP 请求前，要先通过三次握手建立 TCP 连接；
- 如果收到的 HTTP 响应需要重定向，那么将重新开始导航过程；
- 响应完成后，通过四次挥手断开 TCP 连接。

浏览器的网络进程中一旦收到响应头数据（注意，是收到响应头而不是响应体），即便此时响应体中的 HTML 页面数据还没收到，也会通知浏览器主进程，从而进入后续的**准备渲染进程**阶段。

## （六）准备渲染进程、提交文档、确认文档被提交

接上文，当浏览器的网络进程收到响应头后，会同浏览器主进程、渲染进程进行密切配合，最终确认 HTML 文档的提交。

具体流程是这样：

1. 网络进程收到响应头数据，将数据发送给浏览器主进程；
2. 浏览器主进程收到网络进程传来的响应头数据，准备渲染进程；
3. 准备好渲染进程后，浏览器主进程向渲染进程发起“提交文档”的消息；
4. 渲染进程收到浏览器主进程传来的“提交文档”消息，之后会与网络进程建立传输 HTML 页面数据管道；
5. 当网络进程中的响应体接收完毕，通过管道将 HTML 页面数据传输给渲染进程；
6. 当 HTML 页面数据传输完成后，渲染进程会返回“确认文档提交”消息给浏览器主进程；
7. 浏览器主进程收到“确认文档提交”消息后，就会更新浏览器界面的状态，比如安全状态、地址栏 URL、历史记录状态，并刷新 Web 页面。

随着浏览器主进程收到“确认文档提交”消息，然后去更新界面，也意味着整个“导航”过程就结束了，接下来就看渲染进程如何来解析、渲染 HTML 页面了。

## （七）渲染阶段

当渲染进程将“确认文档提交”消息发送给浏览器主进程后，就开始进行页面解析、页面资源加载以及渲染了。

整个渲染阶段的过程可以拆分成许多子阶段，每个阶段的处理都有输入和输出，所以整个渲染阶段也被称为**渲染流水线**

渲染流水线有如下几个子阶段：

1. 构建 DOM 树；
2. 样式计算；
3. 布局；
4. 分层；
5. 绘制；
6. 分块；
7. 光栅化；
8. 合成。

下面各个子阶段一一做介绍。

### 构建 DOM 树

浏览器是无法直接理解和使用 HTML 脚本的，所以需要将 HTML 构建成 DOM 树，才能让浏览器理解。

渲染流水线的第一步，就是**根据 HTML 解析生成可以被浏览器理解、处理的 DOM 树（DOM Tree）。**

想要查看 DOM 树很简单，在浏览器控制台输入 `document` 然后回车即可。

打印的 DOM 树几乎和 HTML 一模一样，不过 DOM 树是存在于 JS 内存中的，它可以被 JS 访问和修改。

有了 DOM 树之后，接下来就要处理样式了。

### 样式计算（Recalculate Style）

**在实际布局之前，要先通过样式计算得到 DOM 树中每一个元素的具体样式**，该阶段可以细分为 3 步：

1. 将 CSS 解析成浏览器能够理解、处理的 `styleSheets`（样式表）结构；
2. 对 `styleSheets`（样式表）中的属性值进行标准化处理；
3. 计算 DOM 树中各个节点的具体样式。

#### 1.将 CSS 解析成浏览器能够理解、处理的 `styleSheets`（样式表）结构

和 HTML 一样，浏览器同样无法直接理解 CSS 脚本，所以也需要一步解析，就是将 CSS 脚本解析成 `styleSheets`（样式表）。

那 `styleSheets`（样式表）又是啥呢？在浏览器控制台输入 `document.styleSheets` 就能看到了。

`styleSheets`（样式表）是后续样式处理的操作基础，浏览器是可以进行查询和访问的。

#### 2.对 `styleSheets`（样式表）中的属性值进行标准化处理

属性值标准化是在干啥呢？

比如有这样一段 CSS：

```css
.footer {
  display: none;
  color: blue;
  font-size: 3rem;
  font-weight: bold;
}
```

这段 CSS 中有一些属性值，虽然对于程序员来说比较好记，但是对于浏览器渲染引擎来说缺难以理解（就好比之前提到的域名，用户好记，但计算机难以理解），比如 `blue`、`3rem`、`bold`。

于是就要将这些难以理解的属性值，标准化处理成浏览器容易理解的属性值：

```css
.footer {
  display: none;
  color: rgb(0, 0, 255);
  font-size: 48px;
  font-weight: 700;
}
```

其中：

- `blue` 标准化处理成了 `rgb(0, 0, 255)`；
- `3rem` 标准化处理成了 `48px`；
- `bold` 标准化处理成了 `700`。

这些都是具体的样式数值了，有了标准化后的值，后面的样式处理就会轻松很多。

#### 3.计算 DOM 树中各个节点的具体样式

截止目前，我们有了可被浏览器访问处理的 `styleSheets`（样式表），其中的属性值也被标准化处理了，接下来就要进行样式计算了。

样式计算需要遵循 CSS 的**继承规则**和**层叠规则**。

##### 继承规则

CSS 继承规则就是让子节点去拥有父节点的样式。

查看页面中元素是如何继承样式非常简单，在浏览器调试工具中的 `Styles` 一栏，有 `Inherited from xxx` 的字样，就是在说明该 CSS 规则继承自哪里。

对于一些没有指定样式规则的属性，默认会继承自 `UserAgent` 样式，`UserAgent` 样式是浏览器默认样式。

这也是为什么我们往往实际项目要进行浏览器样式重置（比如引入 `normalize.css`）的原因，就是为了覆盖掉 `UserAgent` 默认样式。

##### 层叠规则

层叠是 CSS 的一个基本特征，层叠规则定义了如何将多个来源的 CSS 属性值进行合并。

#### 样式计算阶段小结

样式计算阶段的输入、中间过程和输出：

- 输入：DOM 树和 CSS 脚本；
- 过程：
  - 将 CSS 解析成浏览器能够理解、处理的 `styleSheets`（样式表）结构；
  - 对 `styleSheets`（样式表）中的属性值进行标准化处理；
  - 计算 DOM 树中各个节点的具体样式，过程中要遵循：
    - 继承规则；
    - 层叠规则；
- 输出：计算得到 DOM 树的每个节点的样式，并保存至 `ComputedStyle`（计算后样式）结构中。

可以通过浏览器调试工具 `Computed` 标签页来查看元素的 `ComputedStyle` 计算后样式值。

### 布局（Layout）

截止目前，我们有了 DOM 树以及 DOM 树中各个元素对应的具体样式，但是还不知道这些元素用于渲染的几何信息。

所以接下来，就**需要计算出 DOM 树中可见元素的几何位置，该过程称为布局**。

浏览器的布局阶段一般分为 2 步：

1. 创建布局树；
2. 布局计算。

#### 1.创建布局树

如果用公式来表示该过程，就是：`DOM 树 + ComputedStyle => 布局树`

浏览器要遍历 DOM 树中的节点，并和 `ComputedStyle` 计算后的样式结合，并将结合后的节点添加到布局树中。

只是这棵布局树，仅包含可见元素，像 `<head>` 标签以及 CSS 中定义了 `display: none` 的元素都不在创建的布局树中（遍历节点过程中被忽略），因为后续的页面渲染根本不需要它们。

#### 2.布局计算

拿到了布局树，接下来就要**计算布局树上各个节点的坐标位置，这个过程称为布局计算**。

布局计算后的结果要重新写会布局树中，所以对于布局计算这步来说，输入的是布局树，输出的还是布局树。

这是布局阶段不合理的一个地方，没有将布局计算过程的输入和输出明确区分出来。所以目前 Chrome 正在重构布局代码，下一代布局系统是 `LayoutNG`，能够清晰地分离输入和输出，并且优化了布局算法。

#### 布局阶段小结

综上，整个布局（Layout）阶段的输入、中间过程、输出：

- 输入：DOM 树、`ComputedStyle` 结构；
- 过程：
  - 创建布局树
  - 布局计算
- 输出：拥有了各节点布局信息的布局树。

## Todo List

1. 补充请求行、请求头、请求体的图；
2. 补充 DNS 解析的图；
3. 补充 UDP 的内容；
4. HTTP 加入 TCP/IP 图中；
5. 完成站点隔离小节内容；
6. 补充 TCP 三次握手的图；
7. 补充响应行、响应头、响应体的图；
8. 补充缓存内容；
9. 补充保持连接 keep-alive 内容；
10. 补充 TCP 四次挥手的图；
11. 补充 准备渲染进程、提交文档、确认文档被提交 的图；
12. 补充 CSS 继承规则的图；
13. 补充 层叠规则 的具体内容；
14. 补充 Computed 标签页的图；
15. 补充 创建布局树 的图。
