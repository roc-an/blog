# 从浏览器地址栏中输入 URL 到看到页面，中间经历了什么？

## （一）概述

这是一道非常综合的面试题，内容涉及了操作系统、浏览器底层原理、网络通信以及页面渲染相关的知识，可以考察应聘者的技术视野和技术深度。

另外抛开面试不谈，如果能够理解从输入 URL 到页面渲染完成的整个过程细节，对于我们进行 Web 性能优化、问题定位都是非常有帮助的，可以让我们站在更高的角度去看待自己写的代码。

这篇文章会对详细流程进行分析，并对涉及到的相关知识进行较详细的讲解。

无论是输入 URL，或是进行网络请求，还是渲染页面，进行这些操作的都是浏览器。现代浏览器采用的都是**多进程架构**，不同进程负责不同的事情，要想把整体流程理解透彻，首先要搞清楚浏览器中有哪些进程，分别负责处理什么事情。

## （二）浏览器的多进程架构

### 线程的并行处理执行

先从线程说起，**线程（Thread）是操作系统能够进行运算调度的最小单位**。也就是说，如果我们的电脑要执行某项任务，没有比线程更小的拆分粒度了。

那么问题来了，执行一项任务，大任务可以拆分成小任务给不同的线程去执行，那线程可以并行处理任务吗？如果可以，那不就能大大缩短执行这个大任务的时间咯？

答案是可以的，**线程可以并行处理任务**。

比如下面这 3 行代码就包含了 3 个要处理的小任务：

```js
let a = 1 + 2; // 任务1：计算 1 + 2 的值，赋值给变量 a
let b = 3 / 3; // 任务2：计算 3 / 3 的值，赋值给变量 b
console.log(a, b); // 任务3：浏览器控制台打印变量 a 和 b 的值
```

如果用**单线程**来处理，需要 3 步，即一个线程依次执行上面的 3 行代码。

但如果用**多线程**来处理，仅需要 2 步：

1. 使用 2 个线程，分别执行任务 1 和任务 2，得到赋值后的变量 a 和变量 b
2. 使用 1 个线程，执行任务 3，打印变量

所以，**线程的并行处理执行可以大大提升性能。**

### 进程负责线程的调度

但是线程多起来了以后，由谁管理呢？这就要说到进程了。

**一个进程（Process）就是操作系统中一个应用程序的运行实例，进程包含多个线程，负责线程的启动和调度，可以支持线程的并行处理执行。**

上面多线程并行处理的代码，如果用图来表示，就是这样：

**进程和线程的关系：**

**1.只要进程中任一线程执行出错，都会导致整个进程崩溃**

比如，如果把之前的 3 行代码改成这样：

```js
let a = 1 + 2; // 任务1：计算 1 + 2 的值，赋值给变量 a
let b = c / 3; // 任务2：计算 c / 3 的值，赋值给变量 b
console.log(a, b); // 任务3：浏览器控制台打印变量 a 和 b 的值
```

在执行任务 2 时，由于找不到变量 `c`，于是执行出错，一旦出错，整个进程也就崩溃了，就轮不到线程再去执行任务 3 了。

**2.线程之间共享进程中的资源**

上图任务执行过程中需要进行变量的赋值/取值操作，也就是数据的写和读，这些数据在进程中是可以被各个线程所共享访问的。

注意，“共享访问”并不意味着“同时访问”，如果同时有好多线程对同一个数据进行读写，那不就乱套了。

于是线程中存在一个叫**互斥锁（Mutex）**的东西。好比在旅游景点想去上个厕所，进去后把锁锁上（Lock），这样其他人再想用厕所就只能外边等着，等上完厕所出来，再把锁解开（Unlock），这样其他人又能接着用了。例子有点糙，不过道理确实是这么个道理。

**3.进程关闭后，操作系统会回收进程占用的内存**

无论进程是正常退出，还是因为线程执行出错而意外崩溃，系统都会对进程执行过程中申请的内存进行回收。如果没有这个机制，内存就会越用越多，最终被用光。

有时候我们打游戏，由于程序写的不好，系统越玩越卡，但一旦关了以后，一切又都好起来了，就是这个道理。

**4.进程间相互隔离**

一般情况下，一个进程只能访问自己的数据，这样做是为了避免进程间互相干扰。一个进程崩溃了，又导致其他进程跟着崩溃，那岂不控制不住了，所以操作系统才会有**进程隔离**的机制。

当然，进程间是允许进行数据交互的，这就要用到 IPC（Inter-Process Communication，进程间通信）了。

### 现代浏览器的多进程架构

终于要说到浏览器了，早期的浏览器都是采用的单进程架构，而目前的浏览器都改为采用**多进程架构**了。

也就是说，浏览器一开，咱们电脑系统上就会运行多个进程。以 Chrome 为例，它的多进程架构如图：

其中：

- 浏览器主进程：负责浏览器界面的展示、用户操作浏览器交互的处理、其他进程的调度以及存储功能；
- 网络进程：负责网络资源加载；
- GPU 进程：处理 GPU 渲染相关的任务，提升图形的渲染速度，降低 CPU 的负担；
- 渲染进程：放在沙箱（Sand Box）中，负责将 HTML/CSS/JS 解析、渲染成页面。排版引擎 Blink 和 V8 引擎都是运行在该进程中。
- 插件进程：负责浏览器插件的运行。单独给插件一个进程是因为插件往往最容易崩溃，不能因为一个插件的崩溃导致浏览器的渲染或是网络加载也崩溃了，所以才单独给了个进程，防止对其他进程干扰（渲染进程也是相对不稳定的，JS 写的烂就会崩溃，所以也单独提了个渲染进程）。

#### 图中的沙箱是怎么回事？为什么渲染进程和插件进程要放到沙箱中？

浏览器**沙箱（Sand Box）**中的进程是不能在硬盘上读写数据的，这样就把里面的进程和操作系统关键的数据进行了隔离。

渲染进程和插件进程放到沙箱中，即便他们运行出错，甚至是执行一些恶意程序，也无法去获取系统操作权限从而破坏系统。

所以把它们放到浏览器沙箱中是基于安全的考虑。

#### 站点隔离

在浏览器中，并不是所有标签页的页面渲染都放在同一个渲染进程中，一般情况下，当新开一个标签页时，都会创建一个新的渲染进程。

#### 多进程架构的优势

- 稳定性：上面已经提到，把不稳定的插件和页面渲染任务，单独放到各自的进程中去，即便它们的进程崩了，也不会影响整个浏览器，这样大大提升了浏览器运行的稳定性；
- 流畅度：
  - 早期单进程架构下，如果写了一段死循环的 JS 代码，那么这段骚代码的执行独占了整个线程，其他线程没有机会执行，就会导致整个浏览器变卡顿甚至无响应。但改为多进程后，即便死循环的代码导致当前渲染进程无响应了，也不会影响其他渲染进程，其他页面还是好好的；
  - 另一个问题是**内存泄漏**，单进程下，如果一个线程的执行程序写的比较烂，出现了内存泄漏，那么即便线程执行后关闭释放了一部分内存，但随着有内存泄露的线程的执行越来越多，没被释放的内存越来越多，最终整个浏览器进程就会越用越“慢”。多进程架构下，即便一个页面有内存泄露，但是当关闭它时，整个对应的渲染进程也推出了，进程占用的内存会被完全回收，这也就解决了内存泄露的问题；
- 安全性：早期单进程浏览器没有沙箱机制，这是非常不安全的。一些用 C/C++ 编写的恶意插件可以直接操作计算机中的资源，而恶意脚本也可以通过浏览器漏洞来获取系统权限。多进程架构下的沙箱机制使得这些安全性问题得到有效解决。

#### 多进程架构的劣势

虽然多进程架构解决了上述的稳定性、流畅度以及安全性问题，但由于架构比较复杂，还是会带来一些问题：

- 资源占用高：每个进程都要包含公共基础结构的副本（比如 JS 运行环境），这就令使用浏览器时占用的内存资源更多；
- 扩展性差：也正是由于架构比较复杂，导致模块与模块间的耦合度较高，比较难以适应新需求。

所以目前 Chrome 团队依然在不断探索，往**面向服务的架构（Services Oriented Architecture，SOA）**方向不断努力。

## （三）从 URL 到页面渲染完成的整体流程

介绍了浏览器的多进程架构，回到题目本身，从用户在浏览器地址栏中输入 URL，到最终看到页面渲染完毕，整体流程如图：

你会发现，整个流程中并不是一个进程单独搞定的，而是由浏览器主进程、网络进程以及渲染进程配合搞定的。

概括地看，可以把整个流程分为以下 4 个阶段：

1. 用户输入 URL，浏览器主进程把收到的 URL 转给网络进程；
2. 网络进程中发起请求，其中还涉及缓存、重定向。等网络进程拿到响应头，解析后，将响应头解析后数据转发给浏览器主进程；
3. 浏览器主进程收到响应头数据，发送“提交导航（Commit Navigation）”消息给渲染进程，渲染进程收到后给浏览器主进程回话，告诉主进程已经准备好接收页面了，发给主进程“确认提交”消息。之后渲染进程和网络进程建立通信管道，准备接收 HTML；
4. 浏览器收到“确认提交”消息后，移除之前的旧页面。渲染进程收到网络进程传来的页面数据后，加载资源、解析，最终完成页面渲染。

图中从用户输入 URL 后浏览器主进程开始处理，到渲染进程收到响应数据开始页面解析前的这段过程，叫**导航**。

下面对各个阶段，按顺序进行详细地说明。
