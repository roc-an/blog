# 宏任务与微任务

## （一）消息队列与事件循环机制

在浏览器多进程架构中，渲染进程是专门用来将 HTML/CSS/JS 解析、渲染成页面的。排版引擎 Blink 和 V8 引擎都运行在渲染进程中：

![浏览器多进程架构](https://user-images.githubusercontent.com/79783808/117564223-abb5a000-b0dd-11eb-8ce1-67cd70d93bb1.png)

渲染进程负责调度相关线程来完成渲染任务。

渲染进程中的**渲染主线程**要做的事情非常多：

* 解析 HTML 成 DOM；
* 进行样式计算；
* 进行布局计算；
* 处理 JS 任务；
* 处理鼠标点击、键盘输入等输入事件；
* 等等...

**消息队列与事件循环机制就是为了确保渲染进程中线程的任务能够有条不紊地执行。**

消息队列、事件循环在渲染进程中是这样的：

如图，其中涉及到：

* 渲染进程中：
  * 渲染主线程及其事件循环机制；
  * 消息队列；
  * I/O（I-Input，O-Output，输入/输出）线程；
* 渲染进程接收到来自其他进程（如网络进程、浏览器主进程）的任务；

其中涉及到**浏览器多进程架构**的背景知识，也可以通过 [从浏览器地址栏中输入 URL 到看到页面，中间经历了什么？](https://github.com/roc-an/blog/issues/3) 这篇文章来简单了解。

我们先通过上图对渲染进程及其内部构造有个简单了解，接下来对其中的关键细节进行说明。

### 为什么要引入事件循环机制

渲染主线程中要执行的任务并不完全都是提前安排好的，也没法都提前安排好。

就比如，浏览器也不知道用户什么时候要鼠标点击、键盘输入，所以要有一种机制，能在渲染主线程运行过程中，还可以接收来自外界的任务并执行。

这时，事件循环机制就显得尤为关键了，这要分开说，一是事件机制，一是循环机制：

* **循环机制**：渲染主线程的源码中是有一个循环语句的，确保线程能够一直循环运行下去；
* **事件机制**：当然渲染主线程也不会那么傻（有事没事都一直跑跑跑），它会监听**消息队列**（下文会详细说）的事件，一旦有事件触发，那么渲染主线程就会被“**激活**”，处理这个事件，如果没有事件，主线程就会被“**挂起**”，这种激活/挂起的机制被称为**系统中断机制**。

**有了事件循环机制，渲染主线程就能够应对由其他线程新发过来的任务了**。

**那么当用户关闭页面时，渲染主线程又要如何退出工作呢？**

渲染主线程中有一个用于标识用户是否要离开页面的变量，每次执行任务后都会去判断该变量，如果要退出，那么就中断所有未执行的任务，然后退出线程。

所以这就能解释为什么咱们有时候点了关闭，要过一阵才能真正退出页面，有一种“迟滞感”，那是因为渲染主线程得执行完当前的任务才会进行退出页面的判断，换句话说，就是被当前正执行的任务给“卡”住了。
