# 宏任务与微任务

> 发布于 2021.05.11，最后更新于 2021.05.11。

## （一）一道面试题引发的血案

面试时总能遇到这种题（甚至是原题）：

```js
async function foo() {
  console.log('foo')
}
async function bar() {
  console.log('bar start')
  await foo()
  console.log('bar end')
}
console.log('script start')
setTimeout(function () {
  console.log('setTimeout')
}, 0)
bar();
new Promise(function (resolve) {
  console.log('promise executor')
  resolve();
}).then(function () {
  console.log('promise then')
})
console.log('script end')
```

然后就问 `console.log()` 的打印顺序。

没点道行的还真不知道这题究竟要考啥，可能以为只是为了考 Promise、Async/Await 的用法，以及同步与异步。

这些都知道可还是没法做对，是因为这里还涉及到了宏任务与微任务。

所以这篇文章的目的就是搞懂宏任务和微任务，后面再遇上类似的执行顺序题目，那就如同喝汤一样了。

## （二）消息队列与事件循环机制

在浏览器多进程架构中，渲染进程是专门用来将 HTML/CSS/JS 解析、渲染成页面的。排版引擎 Blink 和 V8 引擎都运行在渲染进程中：

![浏览器多进程架构](https://user-images.githubusercontent.com/79783808/117564223-abb5a000-b0dd-11eb-8ce1-67cd70d93bb1.png)

渲染进程负责调度相关线程来完成渲染任务。

渲染进程中的**渲染主线程**要做的事情非常多：

* 解析 HTML 成 DOM；
* 进行样式计算；
* 进行布局计算；
* 处理 JS 任务；
* 处理鼠标点击、键盘输入等输入事件；
* 等等...

**消息队列与事件循环机制就是为了确保渲染进程中线程的任务能够有条不紊地执行。**

消息队列、事件循环在渲染进程中是这样的：

如图，其中涉及到：

* 渲染进程中：
  * 渲染主线程及其事件循环机制（V8 引擎就是在渲染主线程上运行的）；
  * 消息队列；
  * I/O（I-Input，O-Output，输入/输出）线程；
* 渲染进程接收到来自其他进程（如网络进程、浏览器主进程）的任务；

其中涉及到**浏览器多进程架构**的背景知识，也可以通过 [从浏览器地址栏中输入 URL 到看到页面，中间经历了什么？](https://github.com/roc-an/blog/issues/3) 这篇文章来简单了解。

我们先通过上图对渲染进程及其内部构造有个简单了解，接下来对其中的关键细节进行说明。

### 为什么要引入事件循环机制

渲染主线程中要执行的任务并不完全都是提前安排好的，也没法都提前安排好。

就比如，浏览器也不知道用户什么时候要鼠标点击、键盘输入，所以要有一种机制，能在渲染主线程运行过程中，还可以接收来自外界的任务并执行。

这时，事件循环机制就显得尤为关键了，这要分开说，一是事件机制，一是循环机制：

* **循环机制**：渲染主线程的源码中是有一个循环语句的，确保线程能够一直循环运行下去；
* **事件机制**：当然渲染主线程也不会那么傻（有事没事都一直跑跑跑），它会监听**消息队列**（下文会详细说）的事件，一旦有事件触发，那么渲染主线程就会被“**激活**”，处理这个事件，如果没有事件，主线程就会被“**挂起**”，这种激活/挂起的机制被称为**系统中断机制**。

**有了事件循环机制，渲染主线程就能够应对由其他线程新发过来的任务了**。

**那么当用户关闭页面时，渲染主线程又要如何退出工作呢？**

渲染主线程中有一个用于标识用户是否要离开页面的变量，每次执行任务后都会去判断该变量，如果要退出，那么就中断所有未执行的任务，然后退出线程。

所以这就能解释为什么咱们有时候点了关闭，要过一阵才能真正退出页面，有一种“迟滞感”，那是因为渲染主线程得执行完当前的任务才会进行退出页面的判断，换句话说，就是被当前正执行的任务给“卡”住了。

### 消息队列

先说什么是**队列**，队列是一种常用的数据结构，特殊之处在于，队列中的任务只能从队尾（队列尾部）插入，也只能从对头（队列头部）取出。

就好比排队挂号，先过去排队的呢，就能先拿到号，后过去排队的只能后拿到号，插队是不允许的，插队会被打。所以对于队列的特征，只要记住**队列是先入先出，后入后出**的就好了。

这里简单对比下还有一种数据结构，叫栈，**栈是先入后出，后入先出的**，对比一下，利于记忆。

**引入消息队列，是为了让渲染主线程能够接收来自其他线程的任务**。

这里用 I/O 线程举例，**I/O 线程是渲染进程中专门用来接收其他进程消息的线程**。

* 比如，网络进程收到了 HTML 页面，于是就将数据发送给渲染进程；
* 再比如，浏览器主进程收到了用户的鼠标点击和键盘输入，于是也将消息发送给渲染进程。

从图中可以看出，**网络进程和浏览器主进程都是将消息发送给了渲染进程中的 I/O 线程，然后 I/O 线程再将这些消息进行组装，进一步通过消息队列发送给渲染主线程**。

举例，当发生以下事件时，对应的任务就会被添加到消息队列中：

* 收到网络进程的 HTML 页面数据，于是将“解析 DOM”任务添加到消息队列；
* 用户改变了浏览器窗口大小，于是将“重新布局”任务添加到消息队列；
* 触发了垃圾回收机制，于是将“垃圾回收”任务添加到消息队列；
* 要执行异步回调，于是将执行回调的逻辑添加到消息队列。

**消息队列中任务的类型**：

* 解析 DOM；
* 样式计算；
* 布局计算；
* CSS 动画处理；
* 文件读写；
* 输入事件（鼠标点击、鼠标移动、鼠标滚动、键盘输入等）；
* WebSocket；
* JS 定时器；
* 微任务；
* 等等......

**渲染主线程、消息队列、I/O 线程三者的配合过程**：

1. I/O 线程通过 IPC 进程间通信，收到其他进程发来的消息，比如鼠标点击；
2. I/O 线程对消息进行组装，然后发送消息到消息队列的队尾，插入队列；
3. 渲染主线程的事件循环机制会循环地从消息队列头部读取任务，然后执行任务，再读取、再执行...；
4. 渲染主线程每次执行任务后，都会判断退出页面的标识变量，如果要退出页面，那么中断后续要执行的所有任务，退出线程。

## （三）宏任务与微任务的由来

不过只有消息队列和事件循环机制还不够灵活，目前已经具备的能力有：

* 渲染主线程可以获取并执行新任务（通过事件循环机制）；
* 渲染主线程可以接收渲染进程内其他线程的消息，也能接收其他进程的消息（通过消息队列）；

但是没有解决**如何执行高优先级任务**的问题：

举个例子，比如使用 `axios`（axios 是基于 Promise 的 HTTP 请求库）进行 AJAX 请求，当收到响应时，内部会触发执行 Promise 的 `resolve()`，从而使 promise 实例的状态从进行中（pending）变为已成功（fulfilled），之后触发执行 `.then()` 中的 JS 逻辑。

那么问题来了，`.then()` 中的逻辑要放在消息队列的哪里进行执行呢？

* 如果采用同步的方式，`.then()` 中的逻辑立即执行，那必然会拉长原本当前正在执行的消息队列的任务，导致执行效率降低；
* 如果采用异步的方式，将 `.then()` 中的逻辑插入到消息队列队尾，去排队等待执行，那实时性又不能确保，因为很可能此时消息队列已经排了很长很长的队了；

所以现在**需要一套机制，能够在任务执行效率和实时性两者之间取一个平衡，既不拉长当前正在执行的任务，也不会粗暴地将一个原本较高优先级的任务放到队尾去排长队，这时，就要用到宏任务与微任务了**。

**消息队列中的任务就是宏任务，宏任务中除了自己要执行的逻辑外，还关联着一个微任务队列**。

**在任务执行过程中，如果产生了微任务，那么就把它添加到当前正执行的宏任务的微任务队列中。当宏任务要执行结束时，会依次执行它自己的微任务队列中的微任务。全部执行完毕后，才轮到下一个宏任务的执行。**

所以回到之前的例子，Promise 执行 `resolve()` 就是一个微任务，`resolve()` 后再执行的 `.then()` 中逻辑：

* `.then()` 微任务会被插入到当前正在执行的宏任务的微任务队列中，等待执行。所以它并没有阻塞到当前宏任务逻辑的执行，从而解决了执行效率的问题；
* `.then()` 微任务也没有被插入消息队列的队尾，而是只要当前宏任务的逻辑执行完，渲染主线程并不会着急执行下一个宏任务，而是先把当前宏任务的微任务队列都执行完，然后再执行下一个宏任务，这又确保了实时性。

以上就是引入宏任务和微任务的初衷，进一步思考，其实就是通过细化了任务的调度粒度（宏任务中维护一个微任务队列），而使得较高优先的任务能够在合适的时机去执行罢了。

## （四）setTimeout

`window.setTimeout()` 用于在指定延时毫秒后执行回调函数：

```js
function log() {
  console.log('学前端我乐此不疲')
}

const timeoutId = window.setTimeout(log, 1000)
```

`setTimeout()` 返回的整数是该定时器的编号，可以通过该编号来清除定时器：

`window.clearTimeout(timeoutId)`

### setTimeout 底层原理

上文提到过，当要执行异步回调时，会将执行回调的逻辑添加到消息队列。

可 `setTimeout()` 是指定一个确切的延时毫秒后执行，所以只是简单地将回调逻辑直接添加到消息队列队尾明显不可行，因为这样就没法控制要执行的时间了。

于是机智的 Chrome 又开辟了另一个结构，叫**延迟 HashMap**，里面专门放定时器回调任务和其他 Chrome 内部要延迟执行的任务。

简单说，**HashMap 是一种数据结构，里面存着 Key-Value 键值对，通过 Key 可以映射取到 Value**。

接一开始的 `setTimeout()` 代码：

```js
function log() {
  console.log('学前端我乐此不疲')
}

const timeoutId = window.setTimeout(log, 1000)
```

当 JS 执行创建定时器的代码时，渲染进程会创建一个回调任务，任务中包含了：

* 回调函数名 `log`；
* 当前发起时间；
* 延迟执行时间 `1000`。

然后将该回调任务添加到延迟 HashMap 中。

渲染主线程的事件循环机制在每次循环时：

1. 先去消息队列中取任务、执行；
2. 再去延迟 HashMap 中判断：
  1. 根据发起时间和延迟执行时间判断 HashMap 结构中每个任务是否到期了；
  2. 如果到期，就去执行；
3. 延迟 HashMap 中所有的到期任务都执行完后，继续下一轮循环。

如果要取消掉还没执行的定时器回调任务，也非常简单：根据定时器 ID 找到延迟 HashMap 中的任务，删除掉就可以了。

综上，设置定时器的整体流程可以用下图表示：

另外注意，**无论是消息队列，还是延迟 HashMap，它们中的任务都是宏任务（其实渲染进程中维护了很多不同优先级的队列，这些队列中的任务都是宏任务，而宏任务中的微任务队列是在宏任务要结束时执行的）**。

## （五）再探宏任务与微任务

通过上面小节我们知道：渲染进程中维护了很多队列及其他存储待执行任务的结构，比如文章中提到的消息队列和延迟 HashMap。渲染主线程的事件循环机制循环地从这些数据结构中取任务、执行任务。

那么在这些数据结构中存储的任务就是**宏任务**。

宏任务的时间间隔是不能精准控制的，因此无法应对高实时性要求的场景。

这时就要引入微任务了。

**微任务就是一个需要异步执行的函数，执行时机是在当前宏任务的主体逻辑执行结束之后、当前宏任务结束之前**。

下面介绍微任务的底层原理。

JS 脚本在执行时，V8 会创建一个全局执行上下文，在上下文内部维护着**微任务队列**。

每个宏任务都关联着一个微任务队列，宏任务执行过程中产生的微任务都会被添加到对应的微任务队列中。

微任务的产生方式有 2 种：

1. 使用 [MutationObserver](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver) 监控 DOM 节点变化。当节点被修改或添加/删除其子节点时，就会触发 DOM 变化时要执行的回调，该回调的执行就属于微任务；
2. Promise 构造函数中调用 `resolve()` 和 `reject()` 都是微任务。然后触发执行 `.then()` 和 `.catch()` 中逻辑。

### 微任务的执行时机

当前宏任务中的逻辑执行完成时，渲染主线程会检查宏任务关联的全局执行上下文中的微任务队列，这个时间点被称为**检查点**。

然后将微任务队列中的所有微任务依次执行。

如果在执行微任务过程中产生了新的微任务，并不会把它推迟到下个宏任务，而是就在当前宏任务的微任务队列中添加，并直到执行完毕。

## （六）MutationObserver

`MutationObserver` 接口提供了监视对 DOM 树所做更改的能力。这是它的规范：[Interface MutationObserver](Interface MutationObserver)

### 使用示例

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="wrapper"></div>
  <script src="./mutationObserver.js"></script>
</body>
</html>
```

```js
document.addEventListener('DOMContentLoaded', () => {
  const wrapper = document.querySelector('#wrapper')

  // 观察器配置
  const observerCfg = {
    attributes: true,
    childList: true,
    subtree: true
  }

  // 创建观察器实例
  const observer = new MutationObserver((mutationsList, observer) => {
    // 为兼容 IE 11，使用了传统的 for 循环
    for (let mutation of mutationsList) {
      if (mutation.type === 'childList') {
        console.log('添加或删除了一个子节点');
      } else if (mutation.type === 'attributes') {
        console.log(`修改了 ${mutation.attributeName} 的属性值`)
      }
    }
  })

  // 开始观察目标节点的变更
  observer.observe(wrapper, observerCfg)

  // 2000ms 后为监视的节点添加子节点
  window.setTimeout(() => {
    const p = document.createElement('p')
    p.textContent = '一天不写代码浑身难受'
    wrapper.appendChild(p)
  }, 2000)
})
```

执行结果：等待 2 秒后，控制台打印出了“添加或删除了一个子节点”。

### MutationObserver 的回调属于微任务

监听 DOM 变化然后做出对应的响应，这是一个高频场景，但处理方案却演进了很多年，直到目前的 MutationObserver 方案。

通过了解 MutationObserver 的产生，有助于我们理解微任务的价值。

最早是通过轮询来监听 DOM 变化的：可以设 `setInterval()` 定时器来每隔多久就检测 DOM 是否变化。但是关键就是设置多久才合适？如果设的间隔太久，那就不及时，如果设的间隔很短，那又会浪费大量的内存资源来不停地检查。

到了 DOM3 时代，引入了 Mutation Event，它采用了观察者模式，先订阅要监听的 DOM 节点，一旦 DOM 改变，就收到通知，然后同步地执行之前设置好的 JS 逻辑。

Mutation Event 确保了实时性，但遇到 DOM 变更频繁的场景（比如动态渲染长列表，一口气创建 200 个子节点）就会出现严重的性能问题，因为每次出现 DOM 变更，这些 JS 逻辑都得同步去执行，大大阻塞了线程的执行。于是该方案逐渐从 DOM 标准中移除了。

DOM4 中，引入 MutationObserver 来取代 Mutation Event。MutationObserver API 能监听 DOM 内容的变化、属性的变化及其子节点的变化。

**MutationObserver 的回调是异步执行的**。每次监视的 DOM 发生变化，先将该 DOM 变化记录起来，等过段时间，再一次性地执行异步回调。

这样可以确保回调的逻辑不会频繁执行，从而影响性能。但接着就是另一个问题，异步回调的执行时机该怎么选？

如果被当做宏任务添加到消息队列的队尾，那就没法确保实时性（因为前面可能排了好多个任务），所以该用微任务：一旦 DOM 发生改变，就会产生 DOM 变化记录的微任务，然后添加到当前宏任务的微任务队列中，等到了检查点，渲染主线程的 V8 引擎就可以依次执行这些微任务了。

综上，MutationObserver API 采用的策略是“异步 + 微任务”：

* 异步：规避了频繁触发 DOM 变化后执行同步函数的性能问题；
* 微任务：确保了实时性。

## （七）题目解析

回到文章开头的题目。通过本篇文章的学习，我们知道：

* `setTimeout()` 的定时器回调属于宏任务，被添加到延迟 HashMap 中；
* Promise 的 `resolve()` 和 `reject()` 属于微任务，执行后触发 `.then()` 和 `.catch()` 的执行。

另外需要知道：

`async` 函数返回一个 Promise 实例。当函数执行的时候，一旦遇到 `await` 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。

于是我对题目的执行顺序做了详细注释：

```js
// foo 函数声明
async function foo() {
  // 执行 2-2-1：同步代码，执行它。打印 'foo'
  console.log('foo')
  // 执行 2-2-2：
  // 关键，这里虽然没有显式写出 return 值，但 async 函数的调用是默认返回 promise 实例的
  // 所以执行到这里，在 V8 引擎内部创建 promise 实例并返回：

  // return new Promise((resolve) => {
  //   resolve()
  // })

  // 执行 resolve() 是一个微任务，它被添加到当前宏任务的微任务队列中
  // 此时当前宏任务的微任务队列中有了第 1 个微任务，等待执行
}

// bar 函数声明
async function bar() {
  // 执行 2-1：同步代码，执行它。打印 'bar start'
  console.log('bar start')
  // 执行 2-2：遇到 await foo()，进入到 foo() 函数

  // 执行 5：
  // 等当前宏任务的同步代码都执行完，终于轮到当前宏任务的微任务队列了。
  // 第 1 个微任务是处理 foo() 返回的 promise 的 resolve()，这里没打印。
  // await foo() 的返回值是 undefined。
  await foo()

  // 执行 6：这一步就相当于第 1 个微任务 resolve() 后要执行的 .then() 逻辑。打印 'bar end'。
  console.log('bar end')
}

// 执行 1：先执行所有同步逻辑。打印 'script start'
console.log('script start')

// setTimeout 的回调是宏任务，创建定时器时将它添加到延迟 HashMap 中，创建时不会立刻执行
// 此时延迟 HashMap 中多了一个定时器的宏任务
setTimeout(function () {
  // 执行 8：终于该轮到之前添加到延迟 HashMap 的下一个宏任务了，执行它。打印 'setTimeout'
  console.log('setTimeout')
}, 0)

// 执行 2：bar() 函数调用，进去执行逻辑
bar();

// 执行 3：new Promise 构造函数中的逻辑是同步的
new Promise(function (resolve) {
  // 执行 3-1：由于是同步的，打印 'promise executor'
  console.log('promise executor')
  // 执行 3-2：
  // 又遇到 resolve() 微任务，将其添加到当前宏任务的微任务队列
  // 此时微任务队列中有了第 2 个微任务，等待执行

  // 执行 7：继续执行微任务队列，这是第 2 个微任务，resolve() 改变 Promise 实例状态
  resolve();
}).then(function () {
  // 执行 7-1：实例状态改变后触发 .then() 中逻辑的执行。打印 'promise then'。
  // 至此，当前宏任务和宏任务关联的微任务队列全部执行完毕。
  console.log('promise then')
})

// 执行 4：依然是同步逻辑，打印 'script end'
console.log('script end')

// 打印顺序：
// 执行 1：'script start'
// 执行 2-1：'bar start'
// 执行 2-2-1：'foo'
// 执行 3-1：'promise executor'
// 执行 4：'script end'
// 执行 6：'bar end'
// 执行 7-1：'promise then'
// 执行 8：'setTimeout'
```

当然，如果再深入 Promise 和 Async/Await 原理，那就又是一篇文章了，其中要涉及到 Generator 函数以及协程（线程中维护着多个协程，协程间互相转交线程的控制权）。

目前本文关于宏任务和微任务的知识已经足够解答这些执行顺序问题了。

## 参考资源

* [source.chromium.org | Chrome 浏览器源码](https://source.chromium.org/)

## Todo List

- [ ] 补充 宏任务与微任务 的图；
- [ ] 长任务使 `setTimeout()` 延后执行；
- [ ] `setTimeout()` 嵌套；
- [ ] 未激活页面的 `setTimeout()` 最小间隔；
- [ ] `setTimeout()` 延迟时间有最大值；
- [ ] 补充 XHR 部分；
- [ ] 外链 Promise、Async/Await 原理解析（含协程）；
