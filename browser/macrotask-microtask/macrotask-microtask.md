# 宏任务与微任务

## （一）消息队列与事件循环机制

在浏览器多进程架构中，渲染进程是专门用来将 HTML/CSS/JS 解析、渲染成页面的。排版引擎 Blink 和 V8 引擎都运行在渲染进程中：

![浏览器多进程架构](https://user-images.githubusercontent.com/79783808/117564223-abb5a000-b0dd-11eb-8ce1-67cd70d93bb1.png)

渲染进程负责调度相关线程来完成渲染任务。

渲染进程中的**渲染主线程**要做的事情非常多：

* 解析 HTML 成 DOM；
* 进行样式计算；
* 进行布局计算；
* 处理 JS 任务；
* 处理鼠标点击、键盘输入等输入事件；
* 等等...

**消息队列与事件循环机制就是为了确保渲染进程中线程的任务能够有条不紊地执行。**

消息队列、事件循环在渲染进程中是这样的：

如图，其中涉及到：

* 渲染进程中：
  * 渲染主线程及其事件循环机制（V8 引擎就是在渲染主线程上运行的）；
  * 消息队列；
  * I/O（I-Input，O-Output，输入/输出）线程；
* 渲染进程接收到来自其他进程（如网络进程、浏览器主进程）的任务；

其中涉及到**浏览器多进程架构**的背景知识，也可以通过 [从浏览器地址栏中输入 URL 到看到页面，中间经历了什么？](https://github.com/roc-an/blog/issues/3) 这篇文章来简单了解。

我们先通过上图对渲染进程及其内部构造有个简单了解，接下来对其中的关键细节进行说明。

### 为什么要引入事件循环机制

渲染主线程中要执行的任务并不完全都是提前安排好的，也没法都提前安排好。

就比如，浏览器也不知道用户什么时候要鼠标点击、键盘输入，所以要有一种机制，能在渲染主线程运行过程中，还可以接收来自外界的任务并执行。

这时，事件循环机制就显得尤为关键了，这要分开说，一是事件机制，一是循环机制：

* **循环机制**：渲染主线程的源码中是有一个循环语句的，确保线程能够一直循环运行下去；
* **事件机制**：当然渲染主线程也不会那么傻（有事没事都一直跑跑跑），它会监听**消息队列**（下文会详细说）的事件，一旦有事件触发，那么渲染主线程就会被“**激活**”，处理这个事件，如果没有事件，主线程就会被“**挂起**”，这种激活/挂起的机制被称为**系统中断机制**。

**有了事件循环机制，渲染主线程就能够应对由其他线程新发过来的任务了**。

**那么当用户关闭页面时，渲染主线程又要如何退出工作呢？**

渲染主线程中有一个用于标识用户是否要离开页面的变量，每次执行任务后都会去判断该变量，如果要退出，那么就中断所有未执行的任务，然后退出线程。

所以这就能解释为什么咱们有时候点了关闭，要过一阵才能真正退出页面，有一种“迟滞感”，那是因为渲染主线程得执行完当前的任务才会进行退出页面的判断，换句话说，就是被当前正执行的任务给“卡”住了。

### 消息队列

先说什么是**队列**，队列是一种常用的数据结构，特殊之处在于，队列中的任务只能从队尾（队列尾部）插入，也只能从对头（队列头部）取出。

就好比排队挂号，先过去排队的呢，就能先拿到号，后过去排队的只能后拿到号，插队是不允许的，插队会被打。所以对于队列的特征，只要记住**队列是先入先出，后入后出**的就好了。

这里简单对比下还有一种数据结构，叫栈，**栈是先入后出，后入先出的**，对比一下，利于记忆。

**引入消息队列，是为了让渲染主线程能够接收来自其他线程的任务**。

这里用 I/O 线程举例，**I/O 线程是渲染进程中专门用来接收其他进程消息的线程**。

* 比如，网络进程收到了 HTML 页面，于是就将数据发送给渲染进程；
* 再比如，浏览器主进程收到了用户的鼠标点击和键盘输入，于是也将消息发送给渲染进程。

从图中可以看出，**网络进程和浏览器主进程都是将消息发送给了渲染进程中的 I/O 线程，然后 I/O 线程再将这些消息进行组装，进一步通过消息队列发送给渲染主线程**。

举例，当发生以下事件时，对应的任务就会被添加到消息队列中：

* 收到网络进程的 HTML 页面数据，于是将“解析 DOM”任务添加到消息队列；
* 用户改变了浏览器窗口大小，于是将“重新布局”任务添加到消息队列；
* 触发了垃圾回收机制，于是将“垃圾回收”任务添加到消息队列；
* 要执行异步回调，于是将执行回调的逻辑添加到消息队列。

**消息队列中任务的类型**：

* 解析 DOM；
* 样式计算；
* 布局计算；
* CSS 动画处理；
* 文件读写；
* 输入事件（鼠标点击、鼠标移动、鼠标滚动、键盘输入等）；
* WebSocket；
* JS 定时器；
* 微任务；
* 等等......

**渲染主线程、消息队列、I/O 线程三者的配合过程**：

1. I/O 线程通过 IPC 进程间通信，收到其他进程发来的消息，比如鼠标点击；
2. I/O 线程对消息进行组装，然后发送消息到消息队列的队尾，插入队列；
3. 渲染主线程的事件循环机制会循环地从消息队列头部读取任务，然后执行任务，再读取、再执行...；
4. 渲染主线程每次执行任务后，都会判断退出页面的标识变量，如果要退出页面，那么中断后续要执行的所有任务，退出线程。

## （二）宏任务与微任务的由来

不过只有消息队列和事件循环机制还不够灵活，目前已经具备的能力有：

* 渲染主线程可以获取并执行新任务（通过事件循环机制）；
* 渲染主线程可以接收渲染进程内其他线程的消息，也能接收其他进程的消息（通过消息队列）；

但是没有解决**如何执行高优先级任务**的问题：

举个例子，比如使用 `axios`（axios 是基于 Promise 的 HTTP 请求库）进行 AJAX 请求，当收到响应时，内部会触发执行 Promise 的 `resolve()` 方法，从而使 promise 实例的状态从进行中（pending）变为已成功（fulfilled），之后触发执行 `.then()` 中的 JS 逻辑。

那么问题来了，`.then()` 中的逻辑要放在消息队列的哪里进行执行呢？

* 如果采用同步的方式，`.then()` 中的逻辑立即执行，那必然会拉长原本当前正在执行的消息队列的任务，导致执行效率降低；
* 如果采用异步的方式，将 `.then()` 中的逻辑插入到消息队列队尾，去排队等待执行，那实时性又不能确保，因为很可能此时消息队列已经排了很长很长的队了；

所以现在**需要一套机制，能够在任务执行效率和实时性两者之间取一个平衡，既不拉长当前正在执行的任务，也不会粗暴地将一个原本较高优先级的任务放到队尾去排长队，这时，就要用到宏任务与微任务了**。

**消息队列中的任务就是宏任务，宏任务中除了自己要执行的逻辑外，还维护着一个微任务队列**。

**在任务执行过程中，如果产生了微任务，那么就把它添加到当前正执行的宏任务的微任务队列中。当宏任务要执行结束时，会依次执行它自己的微任务队列中的微任务。全部执行完毕后，才轮到下一个宏任务的执行。**

所以回到之前的例子，Promise 进行 `resolve()` 后将要执行的 `.then()` 中逻辑就是一个微任务：

* `.then()` 微任务会被插入到当前正在执行的宏任务的微任务队列中，等待执行。所以它并没有阻塞到当前宏任务逻辑的执行，从而解决了执行效率的问题；
* `.then()` 微任务也没有被插入消息队列的队尾，而是只要当前宏任务的逻辑执行完，渲染主线程并不会着急执行下一个宏任务，而是先把当前宏任务的微任务队列都执行完，然后再执行下一个宏任务，这又确保了实时性。

以上就是引入宏任务和微任务的初衷，进一步思考，其实就是通过细化了任务的调度粒度（宏任务中维护一个微任务队列），而使得较高优先的任务能够在合适的时机去执行罢了。

## （三）setTimeout

`window.setTimeout()` 用于在指定延时毫秒后执行回调函数：

```js
const timeoutId = window.setTimeout(() => {
  console.log('学习 JS 使我快乐')
}, 1000)
```

`setTimeout()` 返回的整数是该定时器的编号，可以通过该编号来清除定时器：

`window.clearInterval(timeoutId)`

## 参考资源

* [source.chromium.org | Chrome 浏览器源码](https://source.chromium.org/)

## Todo List

- [ ] 补充 宏任务与微任务 的图。
