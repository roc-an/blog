# 两数相加（链表的应用）

> 发布于 2021.11.16，最后更新于 2021.11.16。
>
> 封面图来自 Pexels 上的 Simon Berger 拍摄的图片

## （一）题目描述

给你两个**非空**的链表，表示两个非负的整数。它们每位数字都是按照**逆序**的方式存储的，并且每个节点只能存储**一位**数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1**：

```
输入：l1 = 2 -> 4 -> 3, l2 = 5 -> 6 -> 4
输出：7 -> 0 -> 8
解释：342 + 465 = 807.
```

**示例 2**：

```
输入：l1 = 0, l2 = 0
输出：0
```

**示例 3**：

```
输入：l1 = 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9, l2 = 9 -> 9 -> 9 -> 9
输出：8 -> 9 -> 9 -> 9 -> 0 -> 0 -> 0 -> 1
```

**提示**：

* 每个链表中的节点数在范围 `[1, 100]` 内
* `0 <= Node.val <= 9`
* 题目数据保证列表表示的数字不含前导零

> 题目来源：力扣（LeetCode）

## （二）链表介绍

上面的题目描述中一上来就提到了链表，所以解决这道题的前提是对链表有一定的概念。

**链表（linked list）是一种在物理上非连续、非顺序的数据结构，由若干节点（node）所组成**。

**单向链表**的每一个节点又包含两部分，一部分是存放数据的变量 `data`，另一部分是指向下一个节点的指针 `next`。

为帮助理解，我画了一个单向链表的图：

链表的第 1 个节点被称为「头节点|，最后 1 个节点被称为「尾节点」，尾节点的 `next` 指针指向空。

数组和链表都属于线性数据结构，它们有什么不同呢？

拿取值方面来说，对于数组，直接通过下标取对应值就可以了。但是对于链表（比如单向链表）其中一个节点 A，只能根据节点 A 的 `next` 指针来找到该节点的下一个节点 B，再根据节点 B 的 `next` 指针找到下一个节点 C...

理解了单向链表，「双向链表」其实也很简单：**双向链表**的每个节点，不仅有指向下一个节点的 `next` 指针，还有着指向上一个节点的 `prev` 指针。这样就可以快速找到一个节点的前置节点了。

双向链表如图：

另外对于链表在**内存中的存储方式**：

* 链表数据在内存中是**随机存储**的，链表的每一个节点分布在内存的不同位置，依靠 `next` 指针关联起来。这样可以灵活有效地利用零散的碎片空间；
* 数组数据在内存中是顺序存储（占用连续、完整的存储空间）的。

### 单向链表的 JavaScript 实现

上菜，一个最简单的单向链表节点构造函数：

```js
function ListNode(val, next) {
  this.val = val === undefined ? 0 : val;
  this.next = next === undefined ? null : next;
}
```

其中，`this.val` 是节点携带的数据，而 `this.next` 就是指向下个节点的指针。

## （三）解题核心思路分析

我画了张图来描述算法思路：

核心思路：

* 观察示例，存在进位的情况。所以需要**变量来存储进位的信息**；
* 遍历 `l1`、`l2`，将当前节点的 `val` 相加，并加上上次计算的进位值，创建新节点，并用 `next` 指向新节点。这是一个**递归**的过程；
* 递归的终止条件：`l1`、`l2` 均遍历完，且不再有进位值。

边界情况考虑：

* 两个链表 `l1`、`l2`，它们不一定等长，所以要**考虑其中一个链表先遍历完的情况**；
* 如果 `l1`、`l2` 都遍历完（也就是尾结点的 `next` 指向 `null`），但此时有进位，那应该用进位值再创建一个新节点（这点很坑）。

## （四）JS 实现“两数相加”算法

上菜：

```js
// 单向链表节点构造函数
function ListNode(val, next) {
  this.val = val === undefined ? 0 : val;
  this.next = next === undefined ? null : next;
}

/**
 * 将两个节点的值相加，得到新节点
 * @param prevNode 新链表的前置节点，初始为 null
 * @param n1 链表 1 的当前节点
 * @param n2 链表 2 的当前节点
 * @param carry 由上一次节点计算得到的待进位数
 * @returns 初始情况下，会 return 新链表头节点，其余情况不需要 return
 */
const setNextNode = (prevNode, n1, n2, carry) => {
  let sum = 0; // 本次计算求和
  // 如果 l1、l2 这两个链表不等长，那么必然有 1 个先遍历完，
  // 这种情况下，n1 和 n2 有 1 个会是 null
  if (n1 !== null) {
    sum += n1.val;
  }
  if (n2 !== null) {
    sum += n2.val;
  }
  // 累加待进位数
  sum += carry;

  // 计算要带到下个节点的进位
  const nextCarry = Math.floor(sum/10);
  // 计算要创建的新节点的 val
  const toSetVal = sum%10;

  // 创建一个 next 指向 null 的新节点
  const node = new ListNode(toSetVal);

  // 下一次计算要传递的 n1、n2
  let nextN1 = null;
  let nextN2 = null;
  if (n1 !== null && n1.next) {
    nextN1 = n1.next;
  }
  if (n2 !== null && n2.next) {
    nextN2 = n2.next;
  }

  // 如果 nextN1 和 nextN2 其中有 1 个不是 null，说明 l1 和 l2 还未遍历完，那么继续遍历
  // 如果 nextN1 和 nextN2 都是 null，但 nextCarry 不为 0，说明虽然 l1 和 l2 已经遍历完了，
  // 但最后一次计算还有进位，因此依然要创建一个新节点
  if (nextN1 !== null || nextN2 !== null || nextCarry !== 0) {
    setNextNode(node, nextN1, nextN2, nextCarry);
  }

  if (prevNode === null) {
    // 初始情况下，会 return 新链表头节点
    return node;
  } else {
    // 让新链表前置节点的 next 指向新创建的节点
    prevNode.next = node;
  }
}

const addTwoNumbers = (l1, l2) => {
  return setNextNode(null, l1, l2, 0);
};

// 测试用例
// 构造 l1：2 -> 4 -> 3
const l1HeadNode = new ListNode(2);
const l1Node2 = l1HeadNode.next = new ListNode(4);
l1Node2.next = new ListNode(3);

// 构造 l2：5 -> 6 -> 4
const l2HeadNode = new ListNode(5);
const l2Node2 = l2HeadNode.next = new ListNode(6);
l2Node2.next = new ListNode(4);

// 期望的新列表：7 -> 0 -> 8
console.log('得到的新链表头节点：', addTwoNumbers(l1HeadNode, l2HeadNode));
```

其中：

* 递归调用了 `setNextNode()` 函数来计算两数相加的和，并创建新节点，搞定 `next` 指向；
* 计算当前新节点 `val` 时，用了 `Math.floor(sum/10)`，向下取整；
* 计算进位时，用了 `sum%10`，取余。

另外我编写了测试用例，并且代码也通过了 LeetCode 上 1568 个测试用例：

完整代码也可以在[这里](https://github.com/roc-an/blog/blob/main/algorithm-topics/addTwoNumbers/code/addTwoNumbers.js)找到。

## （五）时间、空间复杂度分析

记 `m`、`n` 分别为输入链表 `l1`、`l2` 的长度。那么该算法的时间、空间复杂度如下：

* 时间复杂度：O(max(m, n))：因为 `l1`、`l2` 不等长，所以算法最多执行 `max(m, n)` 次，每次进行计算、创建新节点、处理 `next` 指向这些操作都是 O(1) 的；
* 空间复杂度：O(max(m, n))：即 `l1`、`l2` 和新链表的存储长度，该算法没有借助其他数据结构，所以不需要额外的存储空间。另外，新链表的最大长度是 `max(m , n) + 1`，因为要考虑遍历结束还存在进位的情况。

总之，该算法的时间、空间复杂度都是线性的。

## （六）小结

我们在初步分析题目后，介绍了**链表的概念**：物理上非连续、非顺序的数据结构，由若干节点所组成。

并且画图区分了**单向链表**和**双向链表**。

数组与链表有所不同：

* 数组可以直接通过索引取到值，因此数组的查找操作，时间复杂度是 `O(1)`；
* 链表只能通过节点的 `next` 或 `prev` 指针来找到下个目标节点，因此查找值的时间复杂度是 `O(n)`。

我们用 JS 实现了单向链表节点的构造函数，并且实现了完整的“两数相加”算法。

这道题在 LeetCode 上的难度是中等，但我做起来觉得似乎配不上中等（老凡尔赛了）。因为只要跟着题目要求，走完单链表遍历就可以了，并没有借助其他数据结构，也没有太多的新思想。

但我第一次做还是出错了（忘记设 `next` 指向了），这道题的边界情况处理和判断条件并不好写，要想一次性作对还是有挑战的。

最后，感谢阅读，欢迎 Star 和订阅，每次发布新的文章我都会 release，这样好文章一旦发布你就能够收到通知。我的文章更新频率是每周至少 1 篇，上头时可能会 2~3 篇，欢迎大家与我交流！
