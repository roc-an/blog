# MySQL 字段类型怎么定？查这篇就够了

MySQL 字段类型的定义会影响数据的取值范围、精度，以及系统的可靠性。合理定义字段类型可以有效节省存储空间，提升查询和处理速度。

## 整型

MySQL 中整型一共有 5 种：

类型 | 有符号数取值范围 | 无符号数取值范围 | 所占字节数 | 适用场景
-- | -- | -- | -- | --
TINYINT | -128~127 | 0~255 | 1 | 多用于枚举这种取值范围小又固定的场景
SMALLINT | -32768~32767 | 0~65535 | 2 | 用于较小范围的数量统计。比如工厂中某种设备的数量
MEDIUMINT | -8388608~8388607 | 0~16777215 | 3 | 用于较大范围的数量统计。比如车站的单日客流量
INT | -2147483648~2147483647 | 0~4294967295 | 4 | 取值范围足够大，一般不用考虑超限问题，最常用
BIGINT | -9223372036854775808~9223372036854775807 | 0~18446744073709551615 | 8 | 仅处理巨大整数时才用到，比如双 11 交易量、大型门户网站点击量、证券公司衍生品持仓等

整型该怎么定，从两方面考虑：

1. **存储空间**：占用字节数少可以节省存储空间；
2. **可靠性**：所选类型是否会有超出取值范围的风险（优先考虑）。

需要根据实际业务场景在这两方面取一个平衡。**优先考虑取值范围**，因为相比于不满足可靠性带来故障，花钱增加存储空间这种成本是非常小的。

## 浮点型（不精准）

浮点型和定点型都可以处理小数。

单精度浮点数（FLOAT） VS 双精度浮点数（DOUBLE）：

类型 | 有符号数取值范围 | 无符号数取值范围 | 所占字节数
-- | -- | -- | --
FLOAT | (-3.402823466E+38, -1.175494351E-38), 0, (1.175494351E-38, 3.402823466E+38) | 0, (1.175494351E-38, 3.402823466E+38) | 4
DOUBLE | (-1.7976931348623157E+308, -2.2250738585072014E-308), 0, (2.2250738585072014E-308, 1.7976931348623157E+308) | 0, (2.2250738585072014E-308, 1.7976931348623157E+308) | 8

浮点数的无符号数取值范围恰巧是有符号数取值范围的一半。

需要特别注意的是，**浮点型并不精准**，在计算机中只会采用固定位数的二进制来存储浮点型。这种不精准现象很普遍，在众多编程语言中也是类似的，比如 JavaScript 中判断 `0.1 + 0.2 === 0.3` 结果是 `false`，我在另一篇前端文章开头处对浮点数不精准的现象有做详细说明：[《深入理解 JavaScript 中的数字类型》](https://github.com/roc-an/blog/issues/5)。

例如，有张表 `equip`，里面存了两件装备：

id | name | price
-- | -- | --
1 | 饮血剑 | 2.8
2 | 破败王者之刃 | 1.9

如果将字段 `price` 设为 `DOUBLE` 类型，那么对两件装备价格求和：

```sql
SELECT SUM(price) FROM lol.equip;
```

得到的结果是：`4.699999999999999`。

如果再将字段 `price` 类型改为 `FLOAT`，那么结果是 `4.699999928474426`。可以看到用单精度比双精度误差更大，因为双精度用 8 字节来存，单精度用 4 字节，双精度存储的数更精准。

所以，**在精度要求很高的项目中，一定不要使用浮点型**。
