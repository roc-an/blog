# 一段话说透一个前端知识点 - 正则表达式

## 概述

* Regular Expression 使用单个字符串来描述、匹配一系列**符合某个语法规则**的字符串
* 简单说就是按照某种规则去匹配符合条件的字符串

图形化正则表达式的工具：https://regexper.com/

## RegExp 对象与修饰符

JS 通过内置对象 RegExp 支持正则表达式

有两种方法实例化 RegExp 对象：

* 字面量
* 构造函数

字面量示例：`const reg = /\bis\b/g`

构造函数示例：`const reg = new RegExp('\\bis\\b', 'g')`

其中用到了 `g` 修饰符，正则中的修饰符：

* `g`：global，全文搜索。如果不使用，仅搜索到第一个匹配就停止
* `i`：ignore case，忽略大小写。默认大小写敏感
* `m`：multiple lines，多行搜索

## 元字符

正则表达式由两种基本字符类型组成：

* 原义文本字符：即代表它本来含义的字符
* 元字符：表示特殊含义的非字母字符

元字符：

`*` `+` `?` `$` `^` `.` `|` `\` `()` `{}` `[]`

以及：

字符 | 含义
-- | --
\n | 换行符
\r | 回车符
\v | 垂直制表符
\t | 水平制表符
\0 | 空字符
\f | 换页符
\cX | 与 X 对应的控制字符（Ctrl + X）

## 字符类

一般情况下，正则表达式中一个字符就是对应字符串中的一个字符

如果想要匹配具有某些特征的一类字符，就要用到字符类了

关于字符类：

* 可以使用元字符 `[]` 来构建一个简单的字符类
* 字符类是指符合某一特征的一类字符，它是一个泛指，而不是特指某个字符

比如，`[abc]` 把字符 `a` 或 `b` 或 `c` 归为一类，表达式可以匹配这一类的字符

### 字符类取反

* 可以使用元字符 `^` 创建**反向类（也叫负向类）**
* 反向类就是不属于某个类的内容

比如，`[^abc]` 表示“不是字符 `a` 或 `b` 或 `c`”的内容

## 范围类

如果想用字符类来匹配数字，那是很麻烦的：`[0123456789]`，想匹配字母难道要写出来 26 个英文字母吗？

这则表达式提供了范围类：

* 可以用 `[a-z]` 表示从 `a` 到 `z` 的任意字符
* 这是个闭区间，也就是包含 `a` 和 `z` 本身
* 闭区间内是支持连写的，比如 `[a-zA-Z]`，大小写都匹配

## 预定义类 & 边界

正则表达式提供了**预定义类**来匹配常见的字符类：

字符 | 等价类 | 含义
-- | -- | --
`.` | `[^\r\n]` | 除了回车符和换行符之外的所有字符
`\d` | `[0-9]` | digit，数字字符
`\D` | `[^0-9]` | 非数字字符
`\s` | `[\t\n\x0B\f\r]` | space，空白符
`\S` | `[^\t\n\x0B\f\r]` | 非空白符
`\w` | `[a-zA-Z_0-9]` | word，单词字符（字母、数字、下划线）
`\W` | `[^a-zA-Z_0-9]` | 非单词字符

例如，匹配一个 ab + 数字 + 任意字符的字符串：`ab\d.`，如果不用预定义类，就要写成 `ab[0-9][^\r\n]`，很麻烦

**边界**字符：

字符 | 含义
-- | --
`^` | 以 xxx 开始
`$` | 以 xxx 结束
`\b` | word boundary，单词边界
`\B` | 非单词边界

## 量词

量词，顾名思义，就是表示数量的词：

字符 | 含义
-- | --
`?` | 出现 0 次或 1 次（最多出现 1 次）
`+` | 出现 1 次或多次（至少出现 1 次）
`*` | 出现 0 次或多次（任意次）
`{n}` | 恰巧出现 `n` 次
`{m,n}` | 出现 `m` 到 `n` 次
`{n,}` | 至少出现 `n` 次

## 贪婪模式与非贪婪模式

如果字符串是 `'12345678'`，正则是 `/\d{3,6}/`，匹配 3~6 个数字，那么匹配结果是多少？

**默认情况下，正则表达式会进行尽可能多地匹配，直到匹配失败**，就好比一条贪吃蛇，这就是**贪婪模式**

```js
'12345678'.replace(/\d{3,6}/g, 'X'); // 'X78'
```

**非贪婪模式**：让正则表达式尽可能少地去匹配，一旦成功匹配不再继续尝试

使用非贪婪模式的用法很简单，**在量词后加上 `?` 即可**

```js
'12345678'.replace(/\d{3,6}?/g, 'X'); // 'XX78'
```

## 分组

### 分组语法

正则 `Roc{3}` 表示的是匹配 `Ro` + `c` 3 次，而不是整个的 `Roc` 3 次，如果想匹配单词 `Roc` 3 次，那就要用分组了

分组：使用 `()` 可以包裹要分组的内容，使量词作用于分组

例如，想匹配“1 个小写字母和 1 个数字”连续出现 3 次的：

```js
'a1b2c3d4'.replace(/([a-z]\d){3}/g, 'X'); // 'Xd4'
```

### 分组与或配合

可以用 `|` 达到“或”的效果

示例：

```js
'UserAgent'.replace(/User|Agent/g, 'X'); // 'XX'
'UserentUsAgent'.replace(/Us(er|Ag)ent/g, 'X'); // 'XX'
```

### 反向引用

如果需求是这样：`'2021-12-22'` 转为 `'12/22/2021'`，就要用到分组配合反向引用了：

```js
'2021-12-22'.replace(/(\d{4})-(\d{2})-(\d{2})/g, '$2/$3/$1'); // '12/22/2021'
```

**使用 `$` 可以捕获分组内容，捕获后用 `$1`、`$2`、`$3`... 来代替**

### 忽略分组

如果不希望捕获某些分组，只需要在分组内加上 `?:` 就可以了：

```js
'User roc is OK'.replace(/(?:User).*(OK)/g, '$1'); // 'OK'
```
