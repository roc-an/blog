# 一段话说透一个前端知识点 - 正则表达式

## 概述

* Regular Expression 使用单个字符串来描述、匹配一系列**符合某个语法规则**的字符串
* 简单说就是按照某种规则去匹配符合条件的字符串

图形化正则表达式的工具：https://regexper.com/

## RegExp 对象与修饰符

JS 通过内置对象 RegExp 支持正则表达式

有两种方法实例化 RegExp 对象：

* 字面量
* 构造函数

字面量示例：`const reg = /\bis\b/g`

构造函数示例：`const reg = new RegExp('\\bis\\b', 'g')`

其中用到了 `g` 修饰符，正则中的修饰符：

* `g`：global，全文搜索。如果不使用，仅搜索到第一个匹配就停止
* `i`：ignore case，忽略大小写。默认大小写敏感
* `m`：multiple lines，多行搜索

## 元字符

正则表达式由两种基本字符类型组成：

* 原义文本字符：即代表它本来含义的字符
* 元字符：表示特殊含义的非字母字符

元字符：

`*` `+` `?` `$` `^` `.` `|` `\` `()` `{}` `[]`

以及：

字符 | 含义
-- | --
\n | 换行符
\r | 回车符
\v | 垂直制表符
\t | 水平制表符
\0 | 空字符
\f | 换页符
\cX | 与 X 对应的控制字符（Ctrl + X）

## 字符类

一般情况下，正则表达式中一个字符就是对应字符串中的一个字符

如果想要匹配具有某些特征的一类字符，就要用到字符类了

关于字符类：

* 可以使用元字符 `[]` 来构建一个简单的字符类
* 字符类是指符合某一特征的一类字符，它是一个泛指，而不是特指某个字符

比如，`[abc]` 把字符 `a` 或 `b` 或 `c` 归为一类，表达式可以匹配这一类的字符

### 字符类取反

* 可以使用元字符 `^` 创建**反向类（也叫负向类）**
* 反向类就是不属于某个类的内容

比如，`[^abc]` 表示“不是字符 `a` 或 `b` 或 `c`”的内容

## 范围类

如果想用字符类来匹配数字，那是很麻烦的：`[0123456789]`，想匹配字母难道要写出来 26 个英文字母吗？

这则表达式提供了范围类：

* 可以用 `[a-z]` 表示从 `a` 到 `z` 的任意字符
* 这是个闭区间，也就是包含 `a` 和 `z` 本身
* 闭区间内是支持连写的，比如 `[a-zA-Z]`，大小写都匹配

## 预定义类 & 边界

正则表达式提供了**预定义类**来匹配常见的字符类：

字符 | 等价类 | 含义
-- | -- | --
`.` | `[^\r\n]` | 除了回车符和换行符之外的所有字符
`\d` | `[0-9]` | digit，数字字符
`\D` | `[^0-9]` | 非数字字符
`\s` | `[\t\n\x0B\f\r]` | space，空白符
`\S` | `[^\t\n\x0B\f\r]` | 非空白符
`\w` | `[a-zA-Z_0-9]` | word，单词字符（字母、数字、下划线）
`\W` | `[^a-zA-Z_0-9]` | 非单词字符

例如，匹配一个 ab + 数字 + 任意字符的字符串：`ab\d.`，如果不用预定义类，就要写成 `ab[0-9][^\r\n]`，很麻烦

**边界**字符：

字符 | 含义
-- | --
`^` | 以 xxx 开始
`$` | 以 xxx 结束
`\b` | word boundary，单词边界
`\B` | 非单词边界

## 量词

量词，顾名思义，就是表示数量的词：

字符 | 含义
-- | --
`?` | 出现 0 次或 1 次（最多出现 1 次）
`+` | 出现 1 次或多次（至少出现 1 次）
`*` | 出现 0 次或多次（任意次）
`{n}` | 恰巧出现 `n` 次
`{m,n}` | 出现 `m` 到 `n` 次
`{n,}` | 至少出现 `n` 次

## 贪婪模式与非贪婪模式

如果字符串是 `'12345678'`，正则是 `/\d{3,6}/`，匹配 3~6 个数字，那么匹配结果是多少？

**默认情况下，正则表达式会进行尽可能多地匹配，直到匹配失败**，就好比一条贪吃蛇，这就是**贪婪模式**

```js
'12345678'.replace(/\d{3,6}/g, 'X'); // 'X78'
```

**非贪婪模式**：让正则表达式尽可能少地去匹配，一旦成功匹配不再继续尝试

使用非贪婪模式的用法很简单，**在量词后加上 `?` 即可**

```js
'12345678'.replace(/\d{3,6}?/g, 'X'); // 'XX78'
```
