# 一段话说透一个前端知识点 - NodeJS

## NodeJS 定位

开发 NodeJS 应用需要特别关注 4 点：

* 开发调试
* 框架设计
* 性能优化
* 灾备方案

NodeJS 为什么值得学习？

* NodeJS 拥有广大的 JS 程序员基础，完全开源，因此拥有强大的开发者社区，现在已有成熟的技术体系以及庞大的生态
* NodeJS 被广泛应用在 Web 服务、开发工作流、客户端应用等诸多领域
* 在 Web 服务领域目前对 NodeJS 的接受程度最高，通常用作 BFF（Backend For Frontend，服务于前端的后端）层，说白了就是为前端业务提供数据的后端程序。这类程序的特点是不需要太强的服务器运算能力，但对程序的灵活性有较高要求。这两点特点都与 NodeJS 的优势相吻合。在 Web 服务开发领域搭建一个 NodeJS BFF 层是有很大好处的：
  * 对于 Web 业务，NodeJS 是目前最适合做 BFF 层的技术，能让前端有能力自由组装后台数据，从而减少大量的业务沟通成本，加快业务的迭代速度
  * 前端能自主决定与后端的通讯方式，这让前端有更多精力着手于 Web 应用的性能优化
  * BFF 层不是一个单靠前端就能搞定的事，搭建过程涉及 RPC 调用、系统运维等场景，都需要后端与运维的紧密配合，这会提升开发人员在架构领域的知识经验
* 对于前端工程师自身，虽然 NodeJS 是一门非浏览器技术，但它基于 JS 环境，能让前端工程师快速上手。学会一门非浏览器端技术，对于学习计算机领域的其他知识非常有好处，可以经由 NodeJS 涉足数据库、操作系统、人工智能等领域，让前端不会因技术壁垒将眼界局限于一个浏览器环境内

使用 NodeJS 的难点：

* 除了基于 JS 环境外，其他地方几乎与前端无交集
* 数据结构、设计模式与前端的侧重点不同
* 需要了解 RPC 调用、进程管理等非浏览器端知识
* 在推广 NodeJS 过程中，可能会遇到产品、后台、运维甚至老板等不同角色的质疑，导致前端同学使用 NodeJS 开展业务会遇到阻力。因此，除了补充必要的后台开发知识，和系统运维知识之外，还需要对 NodeJS 的优缺点、它能给业务带来的价值都有非常深入的理解，才能说服他人配合你完成从前端到后台的一整套项目开发

## NodeJS 是什么？

官网的话：

* NodeJS 是一个基于 **Chrome V8 引擎**的 JavaScript 运行环境
* NodeJS 使用了一个**事件驱动**、**非阻塞式 I/O** 的模型，使其轻量又高效

其实，在 NodeJS 里写 JS 和在 Chrome 里写 JS，几乎没有不一样

那不一样在哪里呢？

* NodeJS 没有 BOM API，如 `document`、`window` 等
* 有许多 NodeJS 专属 API，比如文件系统、进程等

对于开发者来说，NodeJS：

* 你在 Chrome 里写 JS 控制浏览器
* NodeJS 让你用类似的方式，控制**整个计算机**

## NodeJS 可以用来做什么？

比较流行的：

* Web 服务
* 构建工作流
* 开发工具
* 游戏
* 客户端应用

### Web 服务

比如腾讯视频，使用了 NodeJS 作为 Web 服务的中间层，主要原因：

* 需要做针对搜索引擎的优化：网页内容可以很好地被搜索引擎收录
* 网页首屏加速：
  * 文档的 `waterfall` -> `Waiting(TTFB)` 等待时长小
  * 下载网页内容的同时加载 CSS
  * 加载首屏后再慢慢加载后续内容

这两点决定了要使用 SSR，于是选择了 NodeJS

使用 NodeJS 作为腾讯视频中间层的考虑：

* 搜索引擎优化 + 首屏加速 = 服务端渲染
* 服务端渲染 + 前后端同构 = NodeJS

### 构建工作流

Automate and enhance your workflow

典型的就是 Gulp 和 Webpack

预处理、打包资源 -> 尽可能少和小的 HTTP 请求 -> 加速网页加载

旧时代构建工具可能会用 Java、Ruby 甚至 Shell，构建工具不可能永远不出问题，也不可能永远满足需求，但非 JS 语言对前端的排错造成了巨大成本，使用 NodeJS 作为构建工具可以让前端有能力排错、迭代、扩展构建工具本身

因此，使用 NodeJS 做前端构建工具，是最保险的选择

### 开发工具

最典型的就是 Visual Studio Code（VS Code），它是基于 NodeJS 的 Electron

Electron 在 NodeJS 基础上，封装了一层浏览器内核，通过 NodeJS 与 Chromium 的结合，让开发者兼具对整个计算机控制的能力以及对网页的渲染能力

### 游戏

典型的是 Wayward，它是一个沙盒类生存游戏，它是基于 NodeJS 的：

* 大型应用需要给开发者/使用者自定义模块的能力
* 使用 NodeJS 做复杂本地应用：
  * 可以利用 JS 的灵活性提供外部扩展
  * JS 庞大的开发者基数让灵活性得到利用

### 客户端应用

典型的 twitch.tv，游戏直播网站的鼻祖，它们的客户端是基于 NodeJS 做的。它们的网页和客户端应用的 UI 是一模一样的：

* 在已有网站的情况下开发新客户端应用
* 用 NodeJS 客户端技术（Electron）实现，可以最大限度复用现有工程

## NodeJS 内置模块

NodeJS 架构图中：

* APPLICATION：开发者写的 NodeJS 应用
* V8(JS Engine)：Application 的 ES 代码通过 V8 引擎来运行，并转发给 OS 层，即操作系统
* NodeJS Bindings，即 OS 层：操作系统层，涉及操作系统的操作，会由 V8 引擎转发到 OS 层，在处理并得到结果后，再由 OS 层将结果返回给 V8，再返回给 Application 的 ES 代码

**Application + V8 + OS 层三者的配合，就诠释了“NodeJS 是基于 Chrome V8 引擎的 JS 运行环境”这句话**

这三者的配合是由很多 NodeJS 内置模块实现的，一些典型的内置模块：

* `fs`：文件系统。通过该模块 API 可以操作 OS 上的文件
* `net`：网络。可以使用 OS 的网络能力
* `process`：进程。记载 NodeJS 进程信息
* `os`：操作系统
   * `os.arch()`：得到 OS 的 CPU 架构
   * `os.cpus()`：可以查看计算机有多少个 CPU、是几核的，以及核的参数
   * `os.freemem()`：查看还有多少剩余内存
* `events`：事件触发器
  * `EventEmitter` 类：用观察者模式实现了事件的收发
    * `emitter.addListener(eventName, listener)`：类似前端的 `addEventListener`

PS: 所有的内置模块都在源码的 `/lib` 目录下

内置模块的调用通路：

应用代码 -> NodeJS 内置模块 -> 调用 C++ 模块得到结果 -> 通过 V8 API 将结果返回到 NodeJS 内置模块 -> 应用代码

NodeJS 内置模块的职责是：负责应用层面到操作系统层面的通信

## 非阻塞 I/O

* I/O 即 Input/Output，一个系统的输入和输出
* 阻塞 I/O 和非阻塞 I/O 的区别就在于**系统接收输入到输出期间，能不能接收其他输入**

比如吃饭这个场景，

如果是去食堂吃，就要排队打饭：排队 -> 等前面的人打饭 -> 轮到自己打饭 -> 吃饭

如果去外面餐厅吃，可以点菜：坐下 -> 点菜 -> 等待 -> 吃饭

对于点菜人员（食堂阿姨、餐厅服务员）来说：

* 食堂排队打饭是阻塞 I/O
* 餐厅点菜是非阻塞 I/O

因为：

* 系统 = 食堂阿姨、餐厅服务员，输入 = 点菜，输出 = 端菜
* 食堂阿姨只能一个人一个人地打 -> 阻塞 I/O，上一个人输入后，直到他得到输出前，下一个人是不能输入的
* 餐厅服务员点菜后可以服务其他客人 -> 非阻塞 I/O

理解非阻塞 I/O 的要点在于：

* 确定一个进行 Input/Output 的系统
* 思考在 I/O 过程中，能不能进行其他 I/O

NodeJS 架构图中，`LibUV` 是 NodeJS 实现异步非阻塞 I/O 的核心模块

整个架构包含 2 个线程：NodeJS 线程，和其他 C++ 线程（不考虑例外，比如应用程序又开了个线程）

我们的**应用代码、V8、Node Bindings（OS 层）以及 LibUV 中的 Event Queue、Event Loop 都是处于 NodeJS 线程中的**

**NodeJS 线程中，I/O 操作都是非阻塞的，它会把大量的计算能力分发到 LibUV 的其他 C++ 线程中去计算，等到其他 C++ 线程计算完毕，再把结果回调到 NodeJS 线程，进而最终结果返回到应用层去**

## NodeJS 异步编程

### callback

NodeJS 回调函数格式规范：第一个参数是 `error`，后面的参数才是结果

### 事件循环

事件循环是让 NodeJS 实现非阻塞 I/O 的一个关键机制

非阻塞 I/O 和 Event Loop 都属于 LibUV 这个 C++ 模块所提供的能力

NodeJS 环境中维护着一些队列：

* 定时器队列
* 文件操作队列

事件循环 EventLoop 会不停地向队列中查找执行回调

每一个事件环都是一个全新的调用栈
